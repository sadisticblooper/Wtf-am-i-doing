<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Skeletal Animation Viewer</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #1a1a1a; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; color: white; }
        #container { width: 100vw; height: 100vh; }
        
        /* UI Styling */
        #ui-layer {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.9);
            padding: 15px;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            gap: 12px;
            width: 300px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.6);
            border: 1px solid #444;
        }
        h3 { margin: 0 0 5px 0; color: #4CAF50; font-size: 16px; border-bottom: 1px solid #444; padding-bottom: 5px; }
        .control-group { display: flex; flex-direction: column; gap: 5px; margin-bottom: 5px; }
        
        button {
            padding: 8px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            transition: background 0.2s;
            font-size: 13px;
        }
        button:hover { background: #45a049; }
        
        input[type="range"] { width: 100%; cursor: pointer; }
        input[type="file"] { font-size: 11px; }
        
        .label { font-size: 11px; color: #aaa; display: flex; justify-content: space-between; }
        .value { color: #fff; font-weight: bold; }
        
        /* Progress Bar */
        #progress-container {
            width: 100%; height: 4px; background: #333; border-radius: 2px; overflow: hidden; margin-top: 5px; display: none;
        }
        #progress-bar { width: 0%; height: 100%; background: #4CAF50; transition: width 0.1s; }
        
        #status { font-size: 11px; color: #ffeb3b; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        
        #anim-controls { display: none; flex-direction: column; gap: 10px; border-top: 1px solid #444; padding-top: 10px; }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>
</head>
<body>

<div id="ui-layer">
    <h3>Skeletal Viewer</h3>
    
    <div class="control-group">
        <label class="label">1. Load Skeleton TXT:</label>
        <input type="file" id="skeletonInput" accept=".txt" />
        <div id="skeleton-status">Waiting for skeleton file...</div>
    </div>

    <div class="control-group">
        <label class="label">2. Load Animation CSV:</label>
        <input type="file" id="csvInput" accept=".csv" disabled />
        <div id="progress-container"><div id="progress-bar"></div></div>
        <div id="status">Load skeleton first</div>
    </div>

    <div id="anim-controls">
        <div class="control-group">
            <div class="label"><span>Timeline</span><span id="frameDisplay" class="value">Frame: 0</span></div>
            <input type="range" id="timeline" min="0" max="100" value="0" step="1">
        </div>
        <div class="control-group">
             <div class="label"><span>Speed</span><span id="speedDisplay" class="value">30 FPS</span></div>
            <input type="range" id="speedInput" min="1" max="120" value="30" step="1">
        </div>
        <button id="playBtn">Play Animation</button>
    </div>
</div>

<div id="container"></div>

<script>
    // ==========================================
    // 1. DATA DEFINITIONS
    // ==========================================
    const BONE_MAP = {
        0: "pelvis", 1: "stomach", 2: "chest", 3: "neck", 4: "head", 5: "hair", 6: "hair1",
        7: "zero_joint_hand_l", 8: "clavicle_l", 9: "arm_l", 10: "forearm_l",
        11: "forearm_twist_l", 12: "hand_l", 13: "weapon_l", 14: "f_big1_l", 15: "f_big2_l", 16: "f_big3_l",
        17: "f_main1_l", 18: "f_main2_l", 19: "f_main3_l", 20: "f_pointer1_l", 21: "f_pointer2_l", 22: "f_pointer3_l",
        23: "scapular_l", 24: "chest_l", 25: "zero_joint_hand_r", 26: "clavicle_r", 27: "arm_r", 28: "forearm_r",
        29: "forearm_twist_r", 30: "hand_r", 31: "weapons_r", 32: "f_big1_r", 33: "f_big2_r", 34: "f_big3_r",
        35: "f_main1_r", 36: "f_main2_r", 37: "f_main3_r", 38: "f_pointer1_r", 39: "f_pointer2_r", 40: "f_pointer3_r",
        41: "scapular_r", 42: "chest_r", 43: "zero_joint_pelvis_l", 44: "thigh_l", 45: "calf_l", 46: "foot_l",
        47: "toe_l", 48: "back_l", 49: "chest_h_49", 50: "stomach_h_50",
        51: "zero_joint_pelvis_r", 52: "thigh_r", 53: "calf_r", 54: "foot_r", 55: "toe_r", 56: "back_r",
        57: "biceps_twist_l", 58: "biceps_twist_r", 59: "thigh_twist_l", 60: "thigh_twist_r",
        61: "foot_r_extra", 62: "toe_r_extra", 63: "weapon_r_extra", 64: "weapon_l_extra", 65: "root_extra",
    };
    
    const NAME_TO_ID = Object.entries(BONE_MAP).reduce((acc, [id, name]) => {
        acc[name] = parseInt(id);
        return acc;
    }, {});

    // ==========================================
    // 2. THREE.JS BOILERPLATE
    // ==========================================
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x222222);
    const gridHelper = new THREE.GridHelper(500, 50, 0x444444, 0x555555);
    scene.add(gridHelper);
    const axesHelper = new THREE.AxesHelper(30);
    scene.add(axesHelper);
    
    // Lighting
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
    scene.add(ambientLight);
    const dirLight = new THREE.DirectionalLight(0xffffff, 0.5);
    dirLight.position.set(50, 200, 100);
    scene.add(dirLight);
    
    // Camera
    const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 2000);
    camera.position.set(0, 150, 350);
    camera.lookAt(0, 100, 0);
    
    // Renderer
    const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    document.getElementById('container').appendChild(renderer.domElement);
    
    // Controls
    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.target.set(0, 100, 0);
    
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // ==========================================
    // 3. STATE MANAGEMENT
    // ==========================================
    let boneIdMap = {};
    let rootGroup = null;
    let skeletonHelper = null;
    const BONE_DEFAULT_COLOR = 0x00ff00;

    // UI References
    const ui = {
        bar: document.getElementById('progress-bar'),
        container: document.getElementById('progress-container'),
        status: document.getElementById('status'),
        skeletonStatus: document.getElementById('skeleton-status'),
        controls: document.getElementById('anim-controls'),
        timeline: document.getElementById('timeline'),
        frameDisplay: document.getElementById('frameDisplay'),
        playBtn: document.getElementById('playBtn'),
        speedDisplay: document.getElementById('speedDisplay'),
        speedInput: document.getElementById('speedInput')
    };

    // ==========================================
    // 4. SKELETON LOADING
    // ==========================================
    function loadSkeletonFromText(skeletonText) {
        if (skeletonHelper) { scene.remove(skeletonHelper); skeletonHelper = null; }
        if (rootGroup) { scene.remove(rootGroup); rootGroup = null; }
        
        boneIdMap = {};

        const lines = skeletonText.split('\n');
        const boneNodes = [];
        
        // First pass: parse all bones
        lines.forEach(line => {
            if (!line.trim()) return;
            const boneMatch = line.match(/"(.*?)"\s*\[(BONE|Group)\]\s*\|\s*G\.Pos:\((.*?)\)\s*\|\s*G\.Rot \(quat\):\((.*?)\)/);
            if (boneMatch) {
                const name = boneMatch[1];
                const posArr = boneMatch[3].split(',').map(Number);
                const rotArr = boneMatch[4].split(',').map(Number);
                if (posArr.length === 3 && rotArr.length === 4) {
                    boneNodes.push({
                        name: name,
                        level: line.search(/\S/) / 2,
                        globalPos: new THREE.Vector3(posArr[0], posArr[1], posArr[2]),
                        globalRot: new THREE.Quaternion(rotArr[0], rotArr[1], rotArr[2], rotArr[3])
                    });
                }
            }
        });

        // Build hierarchy
        rootGroup = new THREE.Group();
        scene.add(rootGroup);
        
        const stack = [];
        
        boneNodes.forEach(node => {
            const bone = new THREE.Bone();
            bone.name = node.name;
            bone.userData = { originalGlobalPos: node.globalPos.clone(), originalGlobalRot: node.globalRot.clone() };
            
            // Add visual cube
            const size = node.name === "pelvis" ? 4 : 1.5;
            const geometry = new THREE.BoxGeometry(size, size, size);
            const material = new THREE.MeshLambertMaterial({ color: BONE_DEFAULT_COLOR });
            const cube = new THREE.Mesh(geometry, material);
            bone.add(cube);
            
            if (NAME_TO_ID.hasOwnProperty(node.name)) {
                boneIdMap[NAME_TO_ID[node.name]] = bone;
            }
            
            // Find parent based on indentation level
            while (stack.length > 0 && stack[stack.length - 1].level >= node.level) {
                stack.pop();
            }
            
            if (stack.length > 0) {
                const parent = stack[stack.length - 1].bone;
                parent.add(bone);
                
                // Calculate local transform from global
                const parentMatrix = new THREE.Matrix4().compose(
                    parent.userData.originalGlobalPos,
                    parent.userData.originalGlobalRot,
                    new THREE.Vector3(1, 1, 1)
                ).invert();
                
                const globalMatrix = new THREE.Matrix4().compose(
                    node.globalPos,
                    node.globalRot,
                    new THREE.Vector3(1, 1, 1)
                );
                
                const localMatrix = parentMatrix.multiply(globalMatrix);
                const localPos = new THREE.Vector3();
                const localRot = new THREE.Quaternion();
                const localScale = new THREE.Vector3();
                localMatrix.decompose(localPos, localRot, localScale);
                
                bone.position.copy(localPos);
                bone.quaternion.copy(localRot);
            } else {
                rootGroup.add(bone);
                bone.position.copy(node.globalPos);
                bone.quaternion.copy(node.globalRot);
            }
            
            stack.push({ bone: bone, level: node.level });
        });

        skeletonHelper = new THREE.SkeletonHelper(rootGroup);
        scene.add(skeletonHelper);
        
        ui.skeletonStatus.innerText = `Skeleton loaded: ${boneNodes.length} bones`;
        ui.skeletonStatus.style.color = "#4CAF50";
        document.getElementById('csvInput').disabled = false;
        ui.status.innerText = "Ready to load animation CSV";
    }

    // ==========================================
    // 5. ANIMATION & PARSING
    // ==========================================
    const animData = {}; 
    let maxLoadedFrame = 0;
    let isPlaying = false;
    let playbackFrame = 1;
    let playbackSpeed = 30;
    let lastTime = 0;

    document.getElementById('skeletonInput').addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (ev) => loadSkeletonFromText(ev.target.result);
        reader.readAsText(file);
    });

    document.getElementById('csvInput').addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (!file) return;
        
        for (let key in animData) delete animData[key];
        maxLoadedFrame = 0; 
        isPlaying = false;
        ui.container.style.display = 'block'; 
        ui.bar.style.width = '0%';
        ui.status.innerText = "Parsing Animation...";
        
        Papa.parse(file, {
            header: true, 
            dynamicTyping: true, 
            skipEmptyLines: true,
            step: function(results, parser) {
                const row = results.data;
                const f = row.frame_number; 
                const bid = row.bone_id;
                
                if (typeof f === 'number' && typeof bid === 'number') {
                    if (f > maxLoadedFrame) maxLoadedFrame = f;
                    if (!animData[f]) animData[f] = [];
                    
                    animData[f].push({
                        id: bid,
                        px: row.position_x, 
                        py: row.position_y, 
                        pz: row.position_z,
                        rx: row.rotation_x,
                        ry: row.rotation_y,
                        rz: row.rotation_z,
                        rw: row.rotation_w
                    });
                }
                
                const progress = parser?._streamer?._rowCount || 0;
                if (progress % 1000 === 0) {
                    const percent = Math.min(95, (progress / 10000) * 100);
                    ui.bar.style.width = percent + '%';
                }
            },
            complete: function() {
                ui.bar.style.width = '100%';
                ui.status.innerText = `Loaded ${maxLoadedFrame} frames`;
                ui.status.style.color = "#4CAF50";
                ui.controls.style.display = 'flex';
                ui.timeline.max = maxLoadedFrame; 
                ui.timeline.value = 1;
                isPlaying = true;
                updatePlayBtn();
                
                if (maxLoadedFrame > 0) {
                    applyFrame(1);
                }
            }
        });
    });

    // ==========================================
    // 6. ANIMATION LOGIC (VIEWER ONLY)
    // ==========================================
    function normalizeQuaternion(q) {
        const length = Math.sqrt(q.x * q.x + q.y * q.y + q.z * q.z + q.w * q.w);
        if (length > 0) {
            return new THREE.Quaternion(q.x / length, q.y / length, q.z / length, q.w / length);
        }
        return new THREE.Quaternion(0, 0, 0, 1);
    }

    function applyFrame(frameIndex) {
        if (!animData[frameIndex] || !rootGroup) return;
        
        const frameBones = animData[frameIndex];
        
        for(let i = 0; i < frameBones.length; i++) {
            const data = frameBones[i];
            const bone = boneIdMap[data.id];
            
            if (bone) {
                // Apply Position directly from CSV
                bone.position.set(data.px, data.py, data.pz);
                
                // Apply Rotation directly from CSV (Normalize for safety)
                const quat = normalizeQuaternion(new THREE.Quaternion(data.rx, data.ry, data.rz, data.rw));
                bone.quaternion.copy(quat);
            }
        }
        
        rootGroup.updateMatrixWorld(true);
        
        // Update UI
        ui.timeline.value = frameIndex;
        ui.frameDisplay.innerText = `Frame: ${frameIndex}`;
        playbackFrame = frameIndex;
    }

    // ==========================================
    // 7. RENDER LOOP & PLAYBACK
    // ==========================================
    ui.playBtn.addEventListener('click', () => { 
        isPlaying = !isPlaying; 
        updatePlayBtn(); 
    });
    
    function updatePlayBtn() { 
        ui.playBtn.innerText = isPlaying ? "Pause" : "Play"; 
        ui.playBtn.style.background = isPlaying ? "#f44336" : "#4CAF50"; 
    }
    
    ui.timeline.addEventListener('input', (e) => { 
        const f = parseInt(e.target.value); 
        if (f >= 1 && f <= maxLoadedFrame) {
            applyFrame(f); 
        }
        if (isPlaying) { 
            isPlaying = false; 
            updatePlayBtn(); 
        }
    });
    
    ui.speedInput.addEventListener('input', (e) => { 
        playbackSpeed = parseInt(e.target.value); 
        ui.speedDisplay.innerText = `${playbackSpeed} FPS`; 
    });

    function animate(time) {
        requestAnimationFrame(animate);
        controls.update();
        
        if (isPlaying && maxLoadedFrame > 0 && rootGroup) {
            const interval = 1000 / playbackSpeed;
            if (time - lastTime > interval) {
                lastTime = time;
                playbackFrame++;
                if (playbackFrame > maxLoadedFrame) playbackFrame = 1; 
                applyFrame(playbackFrame);
            }
        }
        
        renderer.render(scene, camera);
    }
    
    animate(0);
</script>
</body>
</html>
