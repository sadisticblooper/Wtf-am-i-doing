<!DOCTYPE html>
<html>
<head>
    <title>Armature Converter Tool (CSV ↔ GLTF)</title>
    <style>
        body { font-family: "Segoe UI", Roboto, Helvetica, Arial, sans-serif; background: #1a1a1a; color: #eee; padding: 20px; margin: 0; }
        .container { max-width: 800px; margin: 0 auto; background: #2d2d2d; padding: 0; border-radius: 8px; box-shadow: 0 4px 15px rgba(0,0,0,0.6); overflow: hidden; }
        
        /* Tabs */
        .tabs { display: flex; background: #222; border-bottom: 1px solid #444; }
        .tab { flex: 1; padding: 15px; text-align: center; cursor: pointer; background: #222; color: #888; transition: 0.2s; font-weight: bold; border-bottom: 3px solid transparent; }
        .tab:hover { background: #2a2a2a; color: #ddd; }
        .tab.active { background: #333; color: #fff; border-bottom: 3px solid #2196F3; }

        .content-area { padding: 30px; }
        .mode-section { display: none; }
        .mode-section.active { display: block; }

        h2 { margin-top: 0; border-bottom: 1px solid #444; padding-bottom: 10px; color: #fff; }
        p.desc { color: #aaa; font-size: 0.9em; margin-bottom: 25px; line-height: 1.4; }

        /* Form Elements */
        .step { margin-bottom: 25px; }
        label { display: block; margin-bottom: 8px; font-weight: bold; color: #ccc; }
        
        button { background: #2196F3; color: white; border: none; padding: 12px 24px; cursor: pointer; font-size: 16px; margin-top: 10px; border-radius: 4px; width: 100%; font-weight: bold; transition: background 0.2s; }
        button:hover { background: #1976D2; }
        button:disabled { background: #444; color: #777; cursor: not-allowed; }
        
        input[type="file"] { background: #3d3d3d; padding: 10px; width: 100%; box-sizing: border-box; border-radius: 4px; border: 1px solid #555; color: #fff; }
        input[type="number"] { background: #1a1a1a; color: #fff; border: 1px solid #555; padding: 8px; border-radius: 4px; width: 70px; }

        .settings { display: flex; gap: 20px; background: #383838; padding: 15px; border-radius: 4px; align-items: center; }
        
        #status { margin-top: 20px; padding: 15px; background: #111; border-radius: 4px; white-space: pre-wrap; color: #4caf50; font-family: monospace; min-height: 40px; border: 1px solid #333; font-size: 12px; }
        #status.error { color: #ff5252; }
        #status.working { color: #ffeb3b; }
    </style>
</head>
<body>

<div class="container">
    <div class="tabs">
        <div class="tab active" onclick="switchTab('csv-to-gltf')">CSV to GLTF</div>
        <div class="tab" onclick="switchTab('gltf-to-csv')">GLTF to CSV</div>
    </div>

    <div class="content-area">

        <div id="csv-to-gltf" class="mode-section active">
            <h2>CSV to GLTF Armature</h2>
            <p class="desc">
                Upload a CSV containing frame data to generate a visualization of the skeleton (SkinnedMesh) downloadable as a .GLTF file.
            </p>

            <div class="step">
                <label>1. Upload Animation CSV</label>
                <input type="file" id="csv-file" accept=".csv">
            </div>

            <div class="step">
                <label>2. Settings</label>
                <div class="settings">
                    <div>
                        <label style="display:inline; margin-right:5px;">FPS:</label>
                        <input type="number" id="fps-export" value="30">
                    </div>
                    <div>
                        <label style="display:inline; margin-right:5px;">Scale:</label>
                        <input type="number" id="scale-export" value="1.0" step="0.1">
                    </div>
                </div>
            </div>

            <button id="btn-gen-gltf" disabled onclick="generateGLTF()">Download GLTF</button>
        </div>

        <div id="gltf-to-csv" class="mode-section">
            <h2>GLTF to CSV Converter</h2>
            <p class="desc">
                Upload a .GLTF or .GLB file. The tool will sample the animation and generate a CSV using the specific <b>Bone ID Map</b> provided.
            </p>

            <div class="step">
                <label>1. Upload GLTF/GLB</label>
                <input type="file" id="gltf-file" accept=".gltf, .glb">
            </div>

            <div class="step">
                <label>2. Sampling Settings</label>
                <div class="settings">
                    <div>
                        <label style="display:inline; margin-right:5px;">Target FPS:</label>
                        <input type="number" id="fps-import" value="30">
                    </div>
                </div>
            </div>

            <button id="btn-gen-csv" disabled onclick="generateCSV()">Download CSV</button>
        </div>

        <div id="status">Ready.</div>

    </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/exporters/GLTFExporter.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>

<script>
    // --- CONSTANTS ---
    
    // The specific map provided in bone-map.js
    const BONE_MAP = {
        0: "pelvis", 1: "stomach", 2: "chest", 3: "neck", 4: "head", 5: "hair", 6: "hair1",
        7: "zero_joint_hand_l", 8: "clavicle_l", 9: "arm_l", 10: "forearm_l",
        11: "forearm_twist_l", 12: "hand_l", 13: "weapon_l", 14: "f_big1_l", 15: "f_big2_l", 16: "f_big3_l",
        17: "f_main1_l", 18: "f_main2_l", 19: "f_main3_l", 20: "f_pointer1_l", 21: "f_pointer2_l", 22: "f_pointer3_l",
        23: "scapular_l", 24: "chest_l", 25: "zero_joint_hand_r", 26: "clavicle_r", 27: "arm_r", 28: "forearm_r",
        29: "forearm_twist_r", 30: "hand_r", 31: "weapons_r", 32: "f_big1_r", 33: "f_big2_r", 34: "f_big3_r",
        35: "f_main1_r", 36: "f_main2_r", 37: "f_main3_r", 38: "f_pointer1_r", 39: "f_pointer2_r", 40: "f_pointer3_r",
        41: "scapular_r", 42: "chest_r", 43: "zero_joint_pelvis_l", 44: "thigh_l", 45: "calf_l", 46: "foot_l",
        47: "toe_l", 48: "back_l", 49: "chest_h_49", 50: "stomach_h_50",
        51: "zero_joint_pelvis_r", 52: "thigh_r", 53: "calf_r", 54: "foot_r", 55: "toe_r", 56: "back_r",
        57: "biceps_twist_l", 58: "biceps_twist_r", 59: "thigh_twist_l", 60: "thigh_twist_r",
        61: "foot_r_extra", 62: "toe_r_extra", 63: "weapon_r_extra", 64: "weapon_l_extra", 65: "root_extra",
    };

    // Create reverse map for faster lookups (Name -> ID)
    const BONE_NAME_TO_ID = {};
    for (const [id, name] of Object.entries(BONE_MAP)) {
        BONE_NAME_TO_ID[name] = parseInt(id);
    }

    const BONE_VISUAL_SIZE = 2.5; 
    const BONE_COLOR = 0x00ccff;

    // Hardcoded Skeleton Structure for Visualization (CSV -> GLTF)
    const INTERNAL_SKELETON_DATA = `
  "pelvis" [BONE] | G.Pos:(-105.750, 80.938, -7.070) | G.Rot (quat):(0.0196, -0.2812, -0.0333, 0.9589)
    "zero_joint_pelvis_l" [BONE] | G.Pos:(-105.750, 80.938, -7.070) | G.Rot (quat):(0.0196, -0.2812, -0.0333, 0.9589)
      "thigh_l" [BONE] | G.Pos:(-114.096, 82.097, -10.787) | G.Rot (quat):(0.0530, -0.6905, -0.0457, 0.7199)
        "calf_l" [BONE] | G.Pos:(-148.211, 49.767, 3.287) | G.Rot (quat):(0.0499, 0.5731, 0.0009, 0.8180)
          "foot_l" [BONE] | G.Pos:(-152.879, 12.394, -13.223) | G.Rot (quat):(0.0001, -0.3406, -0.0001, 0.9402)
            "toe_l" [BONE] | G.Pos:(-165.312, 2.301, -0.156) | G.Rot (quat):(-0.0032, -0.3406, -0.0013, 0.9402)
        "thigh_twist_l" [BONE] | G.Pos:(-126.585, 69.701, -6.025) | G.Rot (quat):(-0.0305, 0.8869, -0.0166, -0.4607)
      "back_l" [BONE] | G.Pos:(-109.283, 77.661, -19.888) | G.Rot (quat):(0.0238, -0.1512, -0.0304, 0.9878)
    "stomach" [BONE] | G.Pos:(-105.452, 91.816, -5.262) | G.Rot (quat):(-0.0167, -0.3092, -0.0043, 0.9508)
      "chest" [BONE] | G.Pos:(-104.960, 109.559, -5.274) | G.Rot (quat):(-0.0174, -0.2968, 0.0531, 0.9533)
        "zero_joint_hand_l" [BONE] | G.Pos:(-104.960, 109.559, -5.274) | G.Rot (quat):(-0.0174, -0.2968, 0.0531, 0.9533)
          "chest_l" [BONE] | G.Pos:(-123.178, 114.886, 4.693) | G.Rot (quat):(-0.0174, -0.2968, 0.0531, 0.9533)
          "clavicle_l" [BONE] | G.Pos:(-111.292, 133.672, -3.881) | G.Rot (quat):(0.0262, -0.3800, 0.0353, 0.9240)
            "arm_l" [BONE] | G.Pos:(-124.895, 127.953, -14.988) | G.Rot (quat):(-0.0359, -0.7193, 0.0311, 0.6930)
              "biceps_twist_l" [BONE] | G.Pos:(-129.133, 115.620, -19.839) | G.Rot (quat):(0.0489, -0.4303, 0.0512, 0.8999)
              "forearm_l" [BONE] | G.Pos:(-133.711, 102.290, -25.084) | G.Rot (quat):(-0.0730, 0.6346, -0.1745, 0.7493)
                "hand_l" [BONE] | G.Pos:(-151.939, 93.721, -10.975) | G.Rot (quat):(-0.3415, 0.1696, -0.1750, 0.9077)
                  "f_big1_l" [BONE] | G.Pos:(-155.718, 97.132, -7.692) | G.Rot (quat):(-0.4253, 0.1070, -0.0275, 0.8983)
                    "f_big2_l" [BONE] | G.Pos:(-157.912, 97.698, -4.502) | G.Rot (quat):(-0.0922, -0.2801, 0.2271, 0.9282)
                      "f_big3_l" [BONE] | G.Pos:(-159.856, 94.621, -2.271) | G.Rot (quat):(0.4373, -0.3483, 0.4819, 0.6747)
                  "f_pointer1_l" [BONE] | G.Pos:(-163.386, 95.563, -8.128) | G.Rot (quat):(-0.4550, 0.6761, -0.1906, 0.5473)
                    "f_pointer2_l" [BONE] | G.Pos:(-163.214, 94.173, -3.901) | G.Rot (quat):(-0.1801, -0.2028, 0.5427, 0.7949)
                      "f_pointer3_l" [BONE] | G.Pos:(-159.925, 95.151, -3.850) | G.Rot (quat):(-0.2902, 0.1603, 0.5199, 0.7872)
                  "weapon_l" [BONE] | G.Pos:(-159.918, 92.167, -6.401) | G.Rot (quat):(-0.3776, -0.2048, -0.0341, 0.9024)
                  "f_main1_l" [BONE] | G.Pos:(-162.706, 90.379, -9.055) | G.Rot (quat):(-0.1470, 0.8267, -0.5047, -0.2005)
                    "f_main2_l" [BONE] | G.Pos:(-160.501, 90.364, -4.597) | G.Rot (quat):(-0.3344, -0.2478, 0.4239, 0.8044)
                      "f_main3_l" [BONE] | G.Pos:(-156.227, 92.275, -5.487) | G.Rot (quat):(-0.2708, 0.2120, 0.7529, 0.5612)
                "forearm_twist_l" [BONE] | G.Pos:(-142.555, 98.127, -18.233) | G.Rot (quat):(-0.2090, 0.6352, -0.2051, 0.7146)
            "scapular_l" [BONE] | G.Pos:(-123.820, 135.762, -13.573) | G.Rot (quat):(0.0315, -0.5236, 0.0307, 0.8508)
        "zero_joint_hand_r" [BONE] | G.Pos:(-104.960, 109.558, -5.274) | G.Rot (quat):(-0.0229, -0.1942, 0.0510, 0.9794)
          "clavicle_r" [BONE] | G.Pos:(-107.850, 134.073, -1.510) | G.Rot (quat):(-0.1124, 0.8897, 0.2182, 0.3851)
            "arm_r" [BONE] | G.Pos:(-94.099, 133.060, 10.778) | G.Rot (quat):(0.0140, 0.6780, 0.0231, 0.7345)
              "biceps_twist_r" [BONE] | G.Pos:(-85.253, 122.926, 14.328) | G.Rot (quat):(-0.0157, 0.8573, 0.2003, 0.4740)
              "forearm_r" [BONE] | G.Pos:(-75.690, 111.971, 18.161) | G.Rot (quat):(-0.0542, 0.6369, 0.1581, 0.7527)
                "hand_r" [BONE] | G.Pos:(-97.553, 103.356, 25.405) | G.Rot (quat):(-0.1796, 0.7584, 0.0593, 0.6237)
                  "weapon_r" [BONE] | G.Pos:(-106.350, 100.134, 24.666) | G.Rot (quat):(-0.1882, 0.9609, -0.0300, 0.2009)
                  "f_pointer1_r" [BONE] | G.Pos:(-109.469, 103.124, 27.507) | G.Rot (quat):(-0.1277, 0.2454, 0.2590, 0.9254)
                    "f_pointer2_r" [BONE] | G.Pos:(-110.761, 101.110, 23.603) | G.Rot (quat):(0.1165, -0.4460, 0.2506, 0.8513)
                      "f_pointer3_r" [BONE] | G.Pos:(-108.026, 102.616, 22.071) | G.Rot (quat):(-0.2326, 0.8326, -0.1492, -0.4800)
                  "f_big1_r" [BONE] | G.Pos:(-103.074, 105.795, 23.680) | G.Rot (quat):(-0.0521, -0.2608, 0.3611, 0.8938)
                    "f_big2_r" [BONE] | G.Pos:(-106.650, 105.385, 21.638) | G.Rot (quat):(-0.0098, -0.2876, 0.4809, 0.8282)
                      "f_big3_r" [BONE] | G.Pos:(-108.705, 101.246, 20.846) | G.Rot (quat):(-0.1364, -0.1250, 0.9134, 0.3627)
                  "f_main1_r" [BONE] | G.Pos:(-107.275, 98.379, 28.389) | G.Rot (quat):(-0.0124, -0.0000, 0.2680, 0.9633)
                    "f_main2_r" [BONE] | G.Pos:(-107.160, 98.038, 23.672) | G.Rot (quat):(0.1957, -0.5238, 0.1873, 0.8076)
                      "f_main3_r" [BONE] | G.Pos:(-103.682, 100.473, 22.366) | G.Rot (quat):(-0.3849, 0.9121, -0.0674, -0.1245)
                "forearm_twist_r" [BONE] | G.Pos:(-86.304, 107.789, 21.672) | G.Rot (quat):(-0.1882, 0.8120, 0.0961, 0.5441)
            "scapular_r" [BONE] | G.Pos:(-98.689, 139.613, 10.348) | G.Rot (quat):(-0.1059, 0.8780, 0.2213, 0.4110)
          "chest_r" [BONE] | G.Pos:(-108.722, 116.571, 14.634) | G.Rot (quat):(-0.0229, -0.1942, 0.0510, 0.9794)
        "neck" [BONE] | G.Pos:(-109.693, 138.257, -3.259) | G.Rot (quat):(0.0133, -0.3673, 0.0633, 0.9279)
          "head" [BONE] | G.Pos:(-114.410, 150.565, 0.486) | G.Rot (quat):(-0.0088, -0.6652, -0.0368, 0.7457)
            "hair" [BONE] | G.Pos:(-111.927, 165.771, 1.155) | G.Rot (quat):(-0.0088, -0.6652, -0.0368, 0.7457)
    "zero_joint_pelvis_r" [BONE] | G.Pos:(-105.750, 80.937, -7.070) | G.Rot (quat):(0.0295, 0.0545, -0.0249, 0.9978)
      "thigh_r" [BONE] | G.Pos:(-98.825, 80.061, -1.062) | G.Rot (quat):(-0.2016, -0.0074, -0.0294, 0.9790)
        "thigh_twist_r" [BONE] | G.Pos:(-91.769, 65.774, 7.794) | G.Rot (quat):(-0.1614, -0.1410, 0.0105, 0.9767)
        "calf_r" [BONE] | G.Pos:(-79.871, 42.520, 24.212) | G.Rot (quat):(-0.0734, 0.2060, -0.0685, 0.9734)
          "foot_r" [BONE] | G.Pos:(-78.046, 12.250, -3.562) | G.Rot (quat):(-0.0060, -0.8463, 0.0119, 0.5326)
            "toe_r" [BONE] | G.Pos:(-70.829, 2.644, 13.255) | G.Rot (quat):(0.0453, 0.6014, 0.0107, 0.7976)
      "back_r" [BONE] | G.Pos:(-93.463, 75.551, -9.812) | G.Rot (quat):(0.0335, 0.9567, 0.0193, 0.2886)
`;

    // Global Vars
    let csvData = null;
    let loadedGLTF = null; // For CSV conversion

    // -------------------------------------------------------------------------
    // UI LOGIC
    // -------------------------------------------------------------------------
    function switchTab(mode) {
        document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
        document.querySelectorAll('.mode-section').forEach(s => s.classList.remove('active'));
        
        if (mode === 'csv-to-gltf') {
            document.querySelectorAll('.tab')[0].classList.add('active');
            document.getElementById('csv-to-gltf').classList.add('active');
        } else {
            document.querySelectorAll('.tab')[1].classList.add('active');
            document.getElementById('gltf-to-csv').classList.add('active');
        }
        log("Ready.", "normal");
    }

    function log(msg, type="normal") {
        const el = document.getElementById('status');
        el.textContent = msg;
        el.className = "";
        if(type === 'error') el.classList.add('error');
        if(type === 'working') el.classList.add('working');
    }

    // -------------------------------------------------------------------------
    // MODE 1: CSV -> GLTF
    // -------------------------------------------------------------------------
    document.getElementById('csv-file').addEventListener('change', async (e) => {
        const file = e.target.files[0];
        if (!file) return;
        log("Parsing CSV...", "working");
        
        try {
            const text = await file.text();
            csvData = parseCSV(text);
            if (csvData) {
                log(`✓ CSV Loaded: ${Object.keys(csvData.frames).length} frames. Ready to Export.`);
                document.getElementById('btn-gen-gltf').disabled = false;
            } else {
                log("Error: No valid frames found in CSV.", "error");
            }
        } catch(err) {
            log("Error parsing CSV: " + err, "error");
            console.error(err);
        }
    });

    function generateGLTF() {
        if (!csvData) { log("Please upload a CSV first.", "error"); return; }
        log("Generating Geometry & Animation...", "working");

        // 1. Build The Bone Hierarchy (TRUE BONES)
        const skeletonInfo = parseSkeletonText(INTERNAL_SKELETON_DATA);
        if (!skeletonInfo.rootBone) { log("Skeleton parsing failed.", "error"); return; }

        // 2. Create Dummy Skin
        const skinnedMesh = createDummySkinnedMesh(skeletonInfo.bones);
        const scene = new THREE.Scene();
        scene.add(skinnedMesh); 
        scene.add(skeletonInfo.rootBone);

        // 3. Create Clip
        const tracks = createAnimationTracks(skeletonInfo.boneMap, csvData);
        if (tracks.length === 0) { log("Warning: No matching bone names in CSV.", "error"); return; }

        const fps = parseFloat(document.getElementById('fps-export').value) || 30;
        const totalFrames = Object.keys(csvData.frames).map(Number).sort((a,b)=>b-a)[0];
        const duration = totalFrames / fps;
        const clip = new THREE.AnimationClip("Animation", duration, tracks);

        // 4. Export
        log("Processing GLTF file...", "working");
        const exporter = new THREE.GLTFExporter();
        
        exporter.parse(
            scene,
            (gltf) => {
                const blob = new Blob([JSON.stringify(gltf, null, 2)], { type: 'application/gltf+json' });
                downloadBlob(blob, 'skeletal_animation.gltf');
                log("✓ GLTF Export complete.");
            },
            { animations: [clip], onlyVisible: false }
        );
    }

    // -------------------------------------------------------------------------
    // MODE 2: GLTF -> CSV (FIXED NODE MAPPING)
    // -------------------------------------------------------------------------
    document.getElementById('gltf-file').addEventListener('change', async (e) => {
        const file = e.target.files[0];
        if (!file) return;
        
        log("Loading GLTF...", "working");
        const loader = new THREE.GLTFLoader();
        
        // Create a URL for the file object
        const url = URL.createObjectURL(file);
        
        loader.load(url, (gltf) => {
            loadedGLTF = gltf;
            log(`✓ GLTF Loaded. Animations found: ${gltf.animations.length}`);
            document.getElementById('btn-gen-csv').disabled = false;
            URL.revokeObjectURL(url);
        }, undefined, (err) => {
            log("Error loading GLTF: " + err, "error");
        });
    });

    function generateCSV() {
        if (!loadedGLTF) return;
        if (loadedGLTF.animations.length === 0) {
            log("No animations found in this GLTF.", "error");
            return;
        }

        log("Sampling animation frames...", "working");

        // We need to sample the animation at discrete intervals
        const fps = parseFloat(document.getElementById('fps-import').value) || 30;
        const scene = loadedGLTF.scene || loadedGLTF.scenes[0];
        const clip = loadedGLTF.animations[0]; // Take the first animation
        
        const mixer = new THREE.AnimationMixer(scene);
        const action = mixer.clipAction(clip);
        action.play();

        const duration = clip.duration;
        const frameTime = 1 / fps;
        const totalFrames = Math.ceil(duration * fps);

        let csvOutput = "bone_id,bone_name,frame_number,position_x,position_y,position_z,rotation_x,rotation_y,rotation_z,rotation_w\n";
        
        // Collect all bone nodes first
        const bones = [];
        scene.traverse(node => {
            if (node.isBone) bones.push(node);
        });

        if (bones.length === 0) {
            log("No Bone objects found in scene hierarchy.", "error");
            return;
        }

        // Iterate through time
        for (let f = 1; f <= totalFrames; f++) {
            const time = (f-1) * frameTime;
            mixer.setTime(time);
            
            // Force update world matrices (though local transforms are what we usually want in this specific CSV format)
            // ThreeJS updates locals when setTime is called.
            
            bones.forEach((bone) => {
                const boneName = bone.name;
                
                // --- FIX: Lookup proper ID from the Map ---
                let id = BONE_NAME_TO_ID[boneName];
                
                // Handle unmapped bones (assign -1 or keep distinct? Let's use -1 to signal issue)
                if (id === undefined) {
                    console.warn(`Bone "${boneName}" not found in BONE_MAP.`);
                    id = -1; 
                }

                const px = bone.position.x.toFixed(6);
                const py = bone.position.y.toFixed(6);
                const pz = bone.position.z.toFixed(6);
                
                const qx = bone.quaternion.x.toFixed(6);
                const qy = bone.quaternion.y.toFixed(6);
                const qz = bone.quaternion.z.toFixed(6);
                const qw = bone.quaternion.w.toFixed(6);

                // Format: bone_id, bone_name, frame_number, pos_x, pos_y, pos_z, rot_x, rot_y, rot_z, rot_w
                csvOutput += `${id},${boneName},${f},${px},${py},${pz},${qx},${qy},${qz},${qw}\n`;
            });
        }

        const blob = new Blob([csvOutput], { type: 'text/csv' });
        downloadBlob(blob, 'animation_data_fixed.csv');
        log(`✓ CSV Export complete. Processed ${totalFrames} frames. IDs aligned to Bone Map.`);
    }

    // -------------------------------------------------------------------------
    // SHARED UTILS
    // -------------------------------------------------------------------------
    function downloadBlob(blob, filename) {
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
    }

    // -------------------------------------------------------------------------
    // PARSING & HELPERS (CSV TO GLTF LOGIC)
    // -------------------------------------------------------------------------
    function parseCSV(text) {
        const lines = text.trim().split('\n');
        if (lines.length < 2) return null;

        // Parse Header
        const headerRow = lines[0].toLowerCase().split(',').map(s => s.trim().replace(/['"]+/g, ''));
        
        let idx = {
            name: 1, frame: 2, 
            px: 3, py: 4, pz: 5, 
            rx: 6, ry: 7, rz: 8, rw: 9
        };

        function findIdx(keywords) {
            return headerRow.findIndex(h => keywords.some(k => h.includes(k)));
        }

        const nameI = findIdx(['bone_name', 'name']);
        const frameI = findIdx(['frame', 'number']);
        const pxI = findIdx(['position_x', 'pos_x', 'posx']);
        const pyI = findIdx(['position_y', 'pos_y', 'posy']);
        const pzI = findIdx(['position_z', 'pos_z', 'posz']);
        const rxI = findIdx(['rotation_x', 'rot_x', 'rotx']);
        const ryI = findIdx(['rotation_y', 'rot_y', 'roty']);
        const rzI = findIdx(['rotation_z', 'rot_z', 'rotz']);
        const rwI = findIdx(['rotation_w', 'rot_w', 'rotw']);

        if (nameI !== -1) idx.name = nameI;
        if (frameI !== -1) idx.frame = frameI;
        if (pxI !== -1) { idx.px = pxI; idx.py = pyI; idx.pz = pzI; }
        if (rxI !== -1) { idx.rx = rxI; idx.ry = ryI; idx.rz = rzI; idx.rw = rwI; }

        const frames = {};
        
        for (let i = 1; i < lines.length; i++) {
            const line = lines[i].trim();
            if (!line) continue;
            
            const parts = line.split(',');
            if (parts.length < 5) continue; 

            const name = parts[idx.name].trim().replace(/['"]+/g, '');
            const frame = parseInt(parts[idx.frame]);

            if (isNaN(frame)) continue;

            if (!frames[frame]) frames[frame] = {};

            frames[frame][name] = {
                pos: [
                    parseFloat(parts[idx.px]), 
                    parseFloat(parts[idx.py]), 
                    parseFloat(parts[idx.pz])
                ],
                rot: [
                    parseFloat(parts[idx.rx]), 
                    parseFloat(parts[idx.ry]), 
                    parseFloat(parts[idx.rz]), 
                    parseFloat(parts[idx.rw])
                ]
            };
        }
        return { frames: frames };
    }

    function parseSkeletonText(text) {
        const lines = text.split('\n');
        const rootBone = new THREE.Bone();
        rootBone.name = "Root";
        const stack = [{ depth: -1, node: rootBone, globalPos: new THREE.Vector3(0, 0, 0) }]; 
        const boneMap = {};
        const bonesArray = [];

        lines.forEach(line => {
            if (!line.trim()) return;
            const leadingSpaces = line.search(/\S|$/);
            const depth = leadingSpaces; 
            const nameMatch = line.match(/"(.*?)"/);
            const posMatch = line.match(/G\.Pos:\((-?\d+\.\d+), (-?\d+\.\d+), (-?\d+\.\d+)\)/); 
            
            if (!nameMatch || !posMatch) return;
            const boneName = nameMatch[1];
            const globalPos = new THREE.Vector3(parseFloat(posMatch[1]), parseFloat(posMatch[2]), parseFloat(posMatch[3]));
            const bone = new THREE.Bone();
            bone.name = boneName;

            while (stack[stack.length - 1].depth >= depth) stack.pop();
            const parentData = stack[stack.length - 1];
            const localPos = new THREE.Vector3().subVectors(globalPos, parentData.globalPos);
            bone.position.copy(localPos);
            parentData.node.add(bone);
            
            boneMap[boneName] = bone;
            bonesArray.push(bone);
            stack.push({ depth: depth, node: bone, globalPos: globalPos });
        });
        const trueRoot = rootBone.children[0];
        return { rootBone: trueRoot, boneMap: boneMap, bones: bonesArray };
    }

    function createDummySkinnedMesh(bones) {
        const boxGeo = new THREE.BoxGeometry(BONE_VISUAL_SIZE, BONE_VISUAL_SIZE, BONE_VISUAL_SIZE);
        const posArr = [], normArr = [], skinIdxArr = [], skinWtArr = [], indicesArr = [];
        let vertexOffset = 0;
        
        if(bones[0].parent) bones[0].parent.updateMatrixWorld(true);

        for (let i = 0; i < bones.length; i++) {
            const bone = bones[i];
            const worldPos = new THREE.Vector3();
            bone.getWorldPosition(worldPos);

            const count = boxGeo.attributes.position.count;
            for (let v = 0; v < count; v++) {
                posArr.push(
                    boxGeo.attributes.position.getX(v) + worldPos.x,
                    boxGeo.attributes.position.getY(v) + worldPos.y,
                    boxGeo.attributes.position.getZ(v) + worldPos.z
                );
                normArr.push(boxGeo.attributes.normal.getX(v), boxGeo.attributes.normal.getY(v), boxGeo.attributes.normal.getZ(v));
                skinIdxArr.push(i, 0, 0, 0);
                skinWtArr.push(1, 0, 0, 0);
            }
            const indexAttribute = boxGeo.index;
            for (let k = 0; k < indexAttribute.count; k++) indicesArr.push(indexAttribute.getX(k) + vertexOffset);
            vertexOffset += count;
        }

        const finalGeo = new THREE.BufferGeometry();
        finalGeo.setAttribute('position', new THREE.Float32BufferAttribute(posArr, 3));
        finalGeo.setAttribute('normal', new THREE.Float32BufferAttribute(normArr, 3));
        finalGeo.setAttribute('skinIndex', new THREE.Uint16BufferAttribute(skinIdxArr, 4));
        finalGeo.setAttribute('skinWeight', new THREE.Float32BufferAttribute(skinWtArr, 4));
        finalGeo.setIndex(indicesArr);

        const mat = new THREE.MeshStandardMaterial({ color: BONE_COLOR, roughness: 0.4, metalness: 0.1, skinning: true });
        const skinnedMesh = new THREE.SkinnedMesh(finalGeo, mat);
        const skeleton = new THREE.Skeleton(bones);
        skinnedMesh.add(bones[0]);
        skinnedMesh.bind(skeleton);
        return skinnedMesh;
    }

    function createAnimationTracks(boneMap, data) {
        const tracks = [];
        const fps = parseFloat(document.getElementById('fps-export').value) || 30;
        const scale = parseFloat(document.getElementById('scale-export').value) || 1.0;
        const sortedFrames = Object.keys(data.frames).map(Number).sort((a,b) => a-b);

        Object.keys(boneMap).forEach(boneName => {
            const firstFrame = sortedFrames.find(f => data.frames[f][boneName]);
            if (!firstFrame) return;

            const times = [], posValues = [], rotValues = [];
            sortedFrames.forEach(f => {
                const fd = data.frames[f][boneName];
                if (fd) {
                    times.push(f / fps);
                    posValues.push(fd.pos[0] * scale, fd.pos[1] * scale, fd.pos[2] * scale);
                    rotValues.push(fd.rot[0], fd.rot[1], fd.rot[2], fd.rot[3]);
                }
            });
            if (times.length > 0) {
                tracks.push(new THREE.VectorKeyframeTrack(`${boneName}.position`, times, posValues));
                tracks.push(new THREE.QuaternionKeyframeTrack(`${boneName}.quaternion`, times, rotValues));
            }
        });
        return tracks;
    }
</script>

</body>
</html>
