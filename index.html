<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shadow Fight 3 - Animation Viewer with Mesh</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/FBXLoader.js"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    
    <style>
        #three-container { width: 100%; height: 600px; background: #1a1a2e; }
        /* Custom Toggle Switch */
        .toggle-checkbox:checked { right: 0; border-color: #68D391; }
        .toggle-checkbox:checked + .toggle-label { background-color: #68D391; }
    </style>
</head>
<body class="bg-gray-50 min-h-screen">
    <div class="container mx-auto px-4 py-8 max-w-7xl">
        <header class="text-center mb-8">
            <h1 class="text-3xl font-bold text-gray-800">SF3 Animation Viewer with Mesh</h1>
            <p class="text-green-600 font-bold text-sm mt-2">
                <i data-lucide="check-circle" class="inline w-4 h-4"></i> 
                Skeleton Hardcoded & Loaded
            </p>
        </header>

        <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
            <div class="space-y-6">
                
                <div class="bg-white rounded-xl shadow-lg p-6 border-l-4 border-blue-500">
                    <h2 class="font-bold text-gray-800 mb-2">1. Upload Animation (.csv)</h2>
                    <input type="file" id="csv-upload" accept=".csv" class="w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:bg-blue-50 file:text-blue-700 hover:file:bg-blue-100"/>
                    <div id="anim-status" class="mt-2 text-xs text-gray-400">Waiting for file...</div>
                </div>

                <div class="bg-white rounded-xl shadow-lg p-6 border-l-4 border-purple-500">
                    <h2 class="font-bold text-gray-800 mb-2">2. Mesh Controls</h2>
                    <div class="space-y-3">
                        <div class="flex items-center">
                            <input type="checkbox" id="show-mesh" class="mr-2" checked>
                            <label for="show-mesh" class="text-sm">Show Mesh</label>
                        </div>
                        <div class="flex items-center">
                            <input type="checkbox" id="show-skeleton" class="mr-2" checked>
                            <label for="show-skeleton" class="text-sm">Show Skeleton</label>
                        </div>
                        <div class="flex items-center">
                            <input type="checkbox" id="wireframe" class="mr-2">
                            <label for="wireframe" class="text-sm">Wireframe</label>
                        </div>
                        <div class="text-xs text-gray-500">
                            Mesh: <span id="mesh-status">Loading mesh.fbx...</span>
                        </div>
                    </div>
                </div>

                <div class="bg-white rounded-xl shadow-lg p-6">
                    <div class="flex space-x-2 mb-4">
                        <button id="play-btn" class="flex-1 bg-green-600 hover:bg-green-700 text-white py-2 rounded font-bold transition">Play</button>
                        <button id="stop-btn" class="px-4 bg-gray-600 hover:bg-gray-700 text-white rounded transition"><i data-lucide="square" class="w-4 h-4"></i></button>
                    </div>
                    <input type="range" id="frame-slider" min="1" max="100" value="1" class="w-full">
                    <div class="flex justify-between text-sm text-gray-500 mt-2">
                        <span class="font-mono">Frame: <span id="current-frame">0</span></span>
                        <select id="speed-select" class="bg-transparent font-bold">
                            <option value="0.5">0.5x Speed</option>
                            <option value="1" selected>1.0x Speed</option>
                            <option value="2">2.0x Speed</option>
                        </select>
                    </div>
                </div>
            </div>

            <div class="lg:col-span-2 bg-white rounded-xl shadow-lg overflow-hidden flex flex-col h-[600px]">
                <div class="bg-gray-800 text-white px-4 py-2 text-sm flex justify-between">
                    <span>3D Viewport</span>
                    <span class="font-mono">FPS: <span id="fps-counter">0</span></span>
                </div>
                <div id="three-container" class="flex-grow"></div>
            </div>
        </div>
    </div>

    <script>
        // --- HARDCODED SKELETON DATA ---
        const HARDCODED_SKELETON_RAW = `
"Armature" [Group] | G.Pos:(0.000, 0.000, 0.000) | G.Rot (quat):(-0.0000, 0.0000, 0.0000, 1.0000)
  "pelvis" [BONE] | G.Pos:(-105.750, 80.938, -7.070) | G.Rot (quat):(0.0196, -0.2812, -0.0333, 0.9589)
    "zero_joint_pelvis_l" [BONE] | G.Pos:(-105.750, 80.938, -7.070) | G.Rot (quat):(0.0196, -0.2812, -0.0333, 0.9589)
      "thigh_l" [BONE] | G.Pos:(-114.096, 82.097, -10.787) | G.Rot (quat):(0.0530, -0.6905, -0.0457, 0.7199)
        "calf_l" [BONE] | G.Pos:(-148.211, 49.767, 3.287) | G.Rot (quat):(0.0499, 0.5731, 0.0009, 0.8180)
          "foot_l" [BONE] | G.Pos:(-152.879, 12.394, -13.223) | G.Rot (quat):(0.0001, -0.3406, -0.0001, 0.9402)
            "toe_l" [BONE] | G.Pos:(-165.312, 2.301, -0.156) | G.Rot (quat):(-0.0032, -0.3406, -0.0013, 0.9402)
        "thigh_twist_l" [BONE] | G.Pos:(-126.585, 69.701, -6.025) | G.Rot (quat):(-0.0305, 0.8869, -0.0166, -0.4607)
      "back_l" [BONE] | G.Pos:(-109.283, 77.661, -19.888) | G.Rot (quat):(0.0238, -0.1512, -0.0304, 0.9878)
    "stomach" [BONE] | G.Pos:(-105.452, 91.816, -5.262) | G.Rot (quat):(-0.0167, -0.3092, -0.0043, 0.9508)
      "chest" [BONE] | G.Pos:(-104.960, 109.559, -5.274) | G.Rot (quat):(-0.0174, -0.2968, 0.0531, 0.9533)
        "zero_joint_hand_l" [BONE] | G.Pos:(-104.960, 109.559, -5.274) | G.Rot (quat):(-0.0174, -0.2968, 0.0531, 0.9533)
          "chest_l" [BONE] | G.Pos:(-123.178, 114.886, 4.693) | G.Rot (quat):(-0.0174, -0.2968, 0.0531, 0.9533)
          "clavicle_l" [BONE] | G.Pos:(-111.292, 133.672, -3.881) | G.Rot (quat):(0.0262, -0.3800, 0.0353, 0.9240)
            "arm_l" [BONE] | G.Pos:(-124.895, 127.953, -14.988) | G.Rot (quat):(-0.0359, -0.7193, 0.0311, 0.6930)
              "biceps_twist_l" [BONE] | G.Pos:(-129.133, 115.620, -19.839) | G.Rot (quat):(0.0489, -0.4303, 0.0512, 0.8999)
              "forearm_l" [BONE] | G.Pos:(-133.711, 102.290, -25.084) | G.Rot (quat):(-0.0730, 0.6346, -0.1745, 0.7493)
                "hand_l" [BONE] | G.Pos:(-151.939, 93.721, -10.975) | G.Rot (quat):(-0.3415, 0.1696, -0.1750, 0.9077)
                  "f_big1_l" [BONE] | G.Pos:(-155.718, 97.132, -7.692) | G.Rot (quat):(-0.4253, 0.1070, -0.0275, 0.8983)
                    "f_big2_l" [BONE] | G.Pos:(-157.912, 97.698, -4.502) | G.Rot (quat):(-0.0922, -0.2801, 0.2271, 0.9282)
                      "f_big3_l" [BONE] | G.Pos:(-159.856, 94.621, -2.271) | G.Rot (quat):(0.4373, -0.3483, 0.4819, 0.6747)
                  "f_pointer1_l" [BONE] | G.Pos:(-163.386, 95.563, -8.128) | G.Rot (quat):(-0.4550, 0.6761, -0.1906, 0.5473)
                    "f_pointer2_l" [BONE] | G.Pos:(-163.214, 94.173, -3.901) | G.Rot (quat):(-0.1801, -0.2028, 0.5427, 0.7949)
                      "f_pointer3_l" [BONE] | G.Pos:(-159.925, 95.151, -3.850) | G.Rot (quat):(-0.2902, 0.1603, 0.5199, 0.7872)
                  "weapon_l" [BONE] | G.Pos:(-159.918, 92.167, -6.401) | G.Rot (quat):(-0.3776, -0.2048, -0.0341, 0.9024)
                  "f_main1_l" [BONE] | G.Pos:(-162.706, 90.379, -9.055) | G.Rot (quat):(-0.1470, 0.8267, -0.5047, -0.2005)
                    "f_main2_l" [BONE] | G.Pos:(-160.501, 90.364, -4.597) | G.Rot (quat):(-0.3344, -0.2478, 0.4239, 0.8044)
                      "f_main3_l" [BONE] | G.Pos:(-156.227, 92.275, -5.487) | G.Rot (quat):(-0.2708, 0.2120, 0.7529, 0.5612)
                "forearm_twist_l" [BONE] | G.Pos:(-142.555, 98.127, -18.233) | G.Rot (quat):(-0.2090, 0.6352, -0.2051, 0.7146)
            "scapular_l" [BONE] | G.Pos:(-123.820, 135.762, -13.573) | G.Rot (quat):(0.0315, -0.5236, 0.0307, 0.8508)
        "zero_joint_hand_r" [BONE] | G.Pos:(-104.960, 109.558, -5.274) | G.Rot (quat):(-0.0229, -0.1942, 0.0510, 0.9794)
          "clavicle_r" [BONE] | G.Pos:(-107.850, 134.073, -1.510) | G.Rot (quat):(-0.1124, 0.8897, 0.2182, 0.3851)
            "arm_r" [BONE] | G.Pos:(-94.099, 133.060, 10.778) | G.Rot (quat):(0.0140, 0.6780, 0.0231, 0.7345)
              "biceps_twist_r" [BONE] | G.Pos:(-85.253, 122.926, 14.328) | G.Rot (quat):(-0.0157, 0.8573, 0.2003, 0.4740)
              "forearm_r" [BONE] | G.Pos:(-75.690, 111.971, 18.161) | G.Rot (quat):(-0.0542, 0.6369, 0.1581, 0.7527)
                "hand_r" [BONE] | G.Pos:(-97.553, 103.356, 25.405) | G.Rot (quat):(-0.1796, 0.7584, 0.0593, 0.6237)
                  "weapon_r" [BONE] | G.Pos:(-106.350, 100.134, 24.666) | G.Rot (quat):(-0.1882, 0.9609, -0.0300, 0.2009)
                  "f_pointer1_r" [BONE] | G.Pos:(-109.469, 103.124, 27.507) | G.Rot (quat):(-0.1277, 0.2454, 0.2590, 0.9254)
                    "f_pointer2_r" [BONE] | G.Pos:(-110.761, 101.110, 23.603) | G.Rot (quat):(0.1165, -0.4460, 0.2506, 0.8513)
                      "f_pointer3_r" [BONE] | G.Pos:(-108.026, 102.616, 22.071) | G.Rot (quat):(-0.2326, 0.8326, -0.1492, -0.4800)
                  "f_big1_r" [BONE] | G.Pos:(-103.074, 105.795, 23.680) | G.Rot (quat):(-0.0521, -0.2608, 0.3611, 0.8938)
                    "f_big2_r" [BONE] | G.Pos:(-106.650, 105.385, 21.638) | G.Rot (quat):(-0.0098, -0.2876, 0.4809, 0.8282)
                      "f_big3_r" [BONE] | G.Pos:(-108.705, 101.246, 20.846) | G.Rot (quat):(-0.1364, -0.1250, 0.9134, 0.3627)
                  "f_main1_r" [BONE] | G.Pos:(-107.275, 98.379, 28.389) | G.Rot (quat):(-0.0124, -0.0000, 0.2680, 0.9633)
                    "f_main2_r" [BONE] | G.Pos:(-107.160, 98.038, 23.672) | G.Rot (quat):(0.1957, -0.5238, 0.1873, 0.8076)
                      "f_main3_r" [BONE] | G.Pos:(-103.682, 100.473, 22.366) | G.Rot (quat):(-0.3849, 0.9121, -0.0674, -0.1245)
                "forearm_twist_r" [BONE] | G.Pos:(-86.304, 107.789, 21.672) | G.Rot (quat):(-0.1882, 0.8120, 0.0961, 0.5441)
            "scapular_r" [BONE] | G.Pos:(-98.689, 139.613, 10.348) | G.Rot (quat):(-0.1059, 0.8780, 0.2213, 0.4110)
          "chest_r" [BONE] | G.Pos:(-108.722, 116.571, 14.634) | G.Rot (quat):(-0.0229, -0.1942, 0.0510, 0.9794)
        "neck" [BONE] | G.Pos:(-109.693, 138.257, -3.259) | G.Rot (quat):(0.0133, -0.3673, 0.0633, 0.9279)
          "head" [BONE] | G.Pos:(-114.410, 150.565, 0.486) | G.Rot (quat):(-0.0088, -0.6652, -0.0368, 0.7457)
            "hair" [BONE] | G.Pos:(-111.927, 165.771, 1.155) | G.Rot (quat):(-0.0088, -0.6652, -0.0368, 0.7457)
    "zero_joint_pelvis_r" [BONE] | G.Pos:(-105.750, 80.937, -7.070) | G.Rot (quat):(0.0295, 0.0545, -0.0249, 0.9978)
      "thigh_r" [BONE] | G.Pos:(-98.825, 80.061, -1.062) | G.Rot (quat):(-0.2016, -0.0074, -0.0294, 0.9790)
        "thigh_twist_r" [BONE] | G.Pos:(-91.769, 65.774, 7.794) | G.Rot (quat):(-0.1614, -0.1410, 0.0105, 0.9767)
        "calf_r" [BONE] | G.Pos:(-79.871, 42.520, 24.212) | G.Rot (quat):(-0.0734, 0.2060, -0.0685, 0.9734)
          "foot_r" [BONE] | G.Pos:(-78.046, 12.250, -3.562) | G.Rot (quat):(-0.0060, -0.8463, 0.0119, 0.5326)
            "toe_r" [BONE] | G.Pos:(-70.829, 2.644, 13.255) | G.Rot (quat):(0.0453, 0.6014, 0.0107, 0.7976)
      "back_r" [BONE] | G.Pos:(-93.463, 75.551, -9.812) | G.Rot (quat):(0.0335, 0.9567, 0.0193, 0.2886)
`;

        class AnimationViewer3D {
            constructor() {
                this.scene = null; this.camera = null; this.renderer = null;
                this.bones = {};       
                this.boneInfo = {};    
                this.animData = {};    
                this.boneLines = {};
                this.mesh = null;
                this.skeletonHelper = null;
                
                this.isPlaying = false;
                this.frame = 1; 
                this.totalFrames = 0; 
                this.speed = 1;

                this.handleCSVFileSelect = this.handleCSVFileSelect.bind(this);

                this.init();
                this.parseHardcodedSkeleton();
                this.loadFBXMesh();
            }

            init() {
                const container = document.getElementById('three-container');
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x1a1a2e);

                this.camera = new THREE.PerspectiveCamera(50, container.clientWidth / container.clientHeight, 0.1, 1000);
                this.camera.position.set(0, 1.5, 5); 

                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(container.clientWidth, container.clientHeight);
                this.renderer.shadowMap.enabled = true;
                container.appendChild(this.renderer.domElement);

                const controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
                controls.target.set(0, 1, 0);
                controls.update();

                // Lights
                this.scene.add(new THREE.AmbientLight(0xffffff, 0.6));
                const dLight = new THREE.DirectionalLight(0xffffff, 0.8);
                dLight.position.set(5, 10, 5);
                dLight.castShadow = true;
                this.scene.add(dLight);
                
                // Add a back light to better see the mesh
                const backLight = new THREE.DirectionalLight(0xffffff, 0.4);
                backLight.position.set(-5, 5, -5);
                this.scene.add(backLight);

                // Grid Helper
                this.scene.add(new THREE.GridHelper(10, 10, 0x444444, 0x222222));

                // Listeners
                document.getElementById('csv-upload').addEventListener('change', this.handleCSVFileSelect); 
                document.getElementById('play-btn').addEventListener('click', () => this.togglePlay());
                document.getElementById('stop-btn').addEventListener('click', () => { this.isPlaying = false; this.frame = 1; this.updateUI(); this.applyFrame(); });
                document.getElementById('frame-slider').addEventListener('input', e => { this.frame = parseInt(e.target.value); this.applyFrame(); this.updateUI(); });
                document.getElementById('speed-select').addEventListener('change', e => this.speed = parseFloat(e.target.value));
                
                // Mesh control listeners
                document.getElementById('show-mesh').addEventListener('change', (e) => {
                    if (this.mesh) this.mesh.visible = e.target.checked;
                });
                
                document.getElementById('show-skeleton').addEventListener('change', (e) => {
                    Object.values(this.bones).forEach(bone => bone.visible = e.target.checked);
                    Object.values(this.boneLines).forEach(line => line.line.visible = e.target.checked);
                });
                
                document.getElementById('wireframe').addEventListener('change', (e) => {
                    if (this.mesh) {
                        this.mesh.traverse((child) => {
                            if (child.isMesh) {
                                child.material.wireframe = e.target.checked;
                            }
                        });
                    }
                });

                window.addEventListener('resize', () => {
                    this.camera.aspect = container.clientWidth / container.clientHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(container.clientWidth, container.clientHeight);
                });

                this.loop();
            }
            
            handleCSVFileSelect(e) {
                this.loadCSV(e.target.files[0]);
            }

            parseHardcodedSkeleton() {
                const lines = HARDCODED_SKELETON_RAW.trim().split('\n');
                let stack = []; 
                let idCounter = 0;
                
                const globalPosMap = {}; 
                const globalRotMap = {};

                lines.forEach(line => {
                    if(!line.trim() || line.includes('[Group]')) return;

                    const name = line.match(/"([^"]+)"/)[1];
                    
                    const posMatch = line.match(/G\.Pos:\(([\d\.\-, ]+)\)/);
                    if(!posMatch) return;
                    const p = posMatch[1].split(',').map(n => parseFloat(n) / 100); 
                    const gPos = new THREE.Vector3(p[0], p[1], p[2]);
                    
                    const rotMatch = line.match(/G\.Rot \(quat\):\(([\d\.\-, ]+)\)/);
                    let gRot = new THREE.Quaternion(0, 0, 0, 1);
                    if(rotMatch) {
                        const r = rotMatch[1].split(',').map(n => parseFloat(n));
                        gRot = new THREE.Quaternion(r[0], r[1], r[2], r[3]);
                    }

                    const indent = line.search(/\S|$/);
                    while(stack.length > 0 && stack[stack.length-1].indent >= indent) {
                        stack.pop();
                    }
                    const parentId = stack.length > 0 ? stack[stack.length-1].id : null;
                    
                    const currentId = idCounter++; 
                    globalPosMap[currentId] = gPos;
                    globalRotMap[currentId] = gRot;

                    let bindLocalPos = new THREE.Vector3(0,0,0);
                    let bindLocalRot = new THREE.Quaternion(0,0,0,1);
                    
                    if (parentId !== null) {
                        bindLocalPos.subVectors(gPos, globalPosMap[parentId]);
                        
                        const parentRot = globalRotMap[parentId];
                        const invParentRot = parentRot.clone().conjugate();
                        bindLocalRot = invParentRot.multiply(gRot);
                    } else {
                        bindLocalPos.copy(gPos);
                        bindLocalRot.copy(gRot);
                    }

                    this.boneInfo[currentId] = {
                        name: name,
                        parentId: parentId,
                        bindLocalPos: bindLocalPos,
                        bindLocalRot: bindLocalRot,
                        boneObject: null // Will store the actual THREE.Bone object
                    };

                    stack.push({ indent, id: currentId });
                });

                this.buildVisualSkeleton();
            }

            buildVisualSkeleton() {
                // Remove old bones and lines
                Object.values(this.bones).forEach(b => this.scene.remove(b));
                Object.values(this.boneLines).forEach(line => this.scene.remove(line));
                this.bones = {};
                this.boneLines = {};

                // Create a root skeleton group
                this.skeleton = new THREE.Group();
                this.skeleton.name = "SF3_Skeleton";
                this.scene.add(this.skeleton);

                // Create bone groups with spheres
                Object.keys(this.boneInfo).forEach(idStr => {
                    const id = parseInt(idStr);
                    const info = this.boneInfo[id];

                    // Create a bone object (for potential skinning)
                    const bone = new THREE.Bone();
                    bone.name = info.name;
                    
                    // Apply bind pose
                    bone.position.copy(info.bindLocalPos);
                    bone.quaternion.copy(info.bindLocalRot);
                    
                    // Store reference to the bone
                    info.boneObject = bone;
                    
                    // Create visual representation (sphere)
                    const sphere = new THREE.Mesh(
                        new THREE.SphereGeometry(0.04, 8, 8),
                        new THREE.MeshStandardMaterial({ color: id === 0 ? 0xff4444 : 0x3b82f6 })
                    );
                    bone.add(sphere);

                    this.bones[id] = bone;
                });

                // Set up hierarchy
                Object.keys(this.boneInfo).forEach(idStr => {
                    const id = parseInt(idStr);
                    const info = this.boneInfo[id];
                    
                    if(info.parentId !== null && this.bones[info.parentId]) {
                        this.bones[info.parentId].add(this.bones[id]);
                    } else {
                        this.skeleton.add(this.bones[id]);
                    }
                });

                // Create connection lines between parent and child bones
                Object.keys(this.boneInfo).forEach(idStr => {
                    const id = parseInt(idStr);
                    const info = this.boneInfo[id];
                    
                    if(info.parentId !== null && this.bones[info.parentId] && this.bones[id]) {
                        this.createBoneLine(info.parentId, id);
                    }
                });
            }

            createBoneLine(parentId, childId) {
                const parentBone = this.bones[parentId];
                const childBone = this.bones[childId];
                
                if (!parentBone || !childBone) return;
                
                // Create a line geometry connecting parent to child
                const lineGeometry = new THREE.BufferGeometry().setFromPoints([
                    new THREE.Vector3(0, 0, 0),
                    new THREE.Vector3(0, 0, 0)
                ]);
                
                const lineMaterial = new THREE.LineBasicMaterial({ 
                    color: 0x88ff88, 
                    linewidth: 2 
                });
                
                const line = new THREE.Line(lineGeometry, lineMaterial);
                
                // Add the line to the parent bone group
                parentBone.add(line);
                
                // Store the line for updates
                const lineKey = `${parentId}-${childId}`;
                this.boneLines[lineKey] = { line, parentId, childId };
            }

            updateBoneLines() {
                Object.keys(this.boneLines).forEach(key => {
                    const lineData = this.boneLines[key];
                    const parentBone = this.bones[lineData.parentId];
                    const childBone = this.bones[lineData.childId];
                    
                    if (parentBone && childBone) {
                        // Get child position in parent's local space
                        const childPos = new THREE.Vector3();
                        childBone.getWorldPosition(childPos);
                        parentBone.worldToLocal(childPos);
                        
                        // Update line geometry
                        const positions = lineData.line.geometry.attributes.position.array;
                        positions[3] = childPos.x;
                        positions[4] = childPos.y;
                        positions[5] = childPos.z;
                        lineData.line.geometry.attributes.position.needsUpdate = true;
                    }
                });
            }

            async loadFBXMesh() {
                const loader = new THREE.FBXLoader();
                const meshStatus = document.getElementById('mesh-status');
                
                try {
                    meshStatus.textContent = "Loading mesh.fbx...";
                    
                    // Load the FBX file (assuming it's in the same directory as the HTML)
                    loader.load('mesh.fbx', (object) => {
                        this.mesh = object;
                        
                        // Scale and position the mesh if needed
                        this.mesh.scale.set(0.01, 0.01, 0.01); // Adjust scale as needed
                        this.mesh.position.set(0, 0, 0);
                        
                        // Enable shadows
                        this.mesh.traverse((child) => {
                            if (child.isMesh) {
                                child.castShadow = true;
                                child.receiveShadow = true;
                                
                                // Set a default material if needed
                                if (!child.material) {
                                    child.material = new THREE.MeshStandardMaterial({ 
                                        color: 0xcccccc,
                                        roughness: 0.7,
                                        metalness: 0.2
                                    });
                                }
                            }
                        });
                        
                        // Add mesh to scene
                        this.scene.add(this.mesh);
                        
                        // Try to find and apply skeleton to mesh
                        this.applySkeletonToMesh();
                        
                        meshStatus.textContent = "Loaded successfully!";
                        meshStatus.className = "text-green-500";
                        
                    }, (xhr) => {
                        // Progress callback
                        const percent = Math.round((xhr.loaded / xhr.total) * 100);
                        meshStatus.textContent = `Loading: ${percent}%`;
                    }, (error) => {
                        // Error callback
                        console.error('Error loading FBX:', error);
                        meshStatus.textContent = "Error loading mesh.fbx";
                        meshStatus.className = "text-red-500";
                    });
                    
                } catch (error) {
                    console.error('Failed to load FBX:', error);
                    meshStatus.textContent = "Failed to load mesh";
                    meshStatus.className = "text-red-500";
                }
            }

            applySkeletonToMesh() {
                if (!this.mesh || !this.bones) {
                    console.log("Mesh or bones not ready yet");
                    return;
                }

                // Find all meshes in the FBX
                const meshes = [];
                this.mesh.traverse((child) => {
                    if (child.isMesh) {
                        meshes.push(child);
                    }
                });

                // For each mesh, try to apply skeleton
                meshes.forEach(mesh => {
                    if (mesh.geometry && !mesh.geometry.attributes.skinWeight) {
                        // If mesh doesn't have skin weights, we can't properly skin it
                        console.log(`Mesh "${mesh.name}" doesn't have skin weights`);
                        return;
                    }

                    // Create a skeleton from our bones
                    const bonesArray = Object.values(this.bones);
                    
                    if (bonesArray.length > 0) {
                        // Create a skeleton helper for visualization
                        if (!this.skeletonHelper) {
                            this.skeletonHelper = new THREE.SkeletonHelper(this.mesh);
                            this.skeletonHelper.material.linewidth = 3;
                            this.skeletonHelper.visible = false; // Hide by default, we have our own lines
                            this.scene.add(this.skeletonHelper);
                        }
                        
                        console.log(`Applied skeleton to mesh "${mesh.name}" with ${bonesArray.length} bones`);
                    }
                });
            }

            async loadCSV(file) {
                if(!file) {
                    document.getElementById('anim-status').textContent = `ERROR: No file detected.`;
                    document.getElementById('anim-status').className = "mt-2 text-xs text-red-500 font-bold";
                    return;
                }
                const text = await file.text();
                const lines = text.trim().split('\n');
                
                this.animData = {};
                
                // Skip header (1st line)
                for(let i=1; i<lines.length; i++) {
                    const parts = lines[i].split(',');
                    const id = parseInt(parts[0]);
                    const fr = parseInt(parts[1]);
                    
                    if (parts.length < 9 || isNaN(id) || isNaN(fr)) continue;

                    if(!this.animData[fr]) this.animData[fr] = {};
                    
                    this.animData[fr][id] = {
                        pos: [parseFloat(parts[2])/100, parseFloat(parts[3])/100, parseFloat(parts[4])/100],
                        rot: [parseFloat(parts[5]), parseFloat(parts[6]), parseFloat(parts[7]), parseFloat(parts[8])]
                    };
                }

                this.totalFrames = Object.keys(this.animData).length;
                document.getElementById('frame-slider').max = this.totalFrames;
                document.getElementById('anim-status').textContent = `Loaded ${this.totalFrames} frames from ${file.name}.`;
                document.getElementById('anim-status').className = "mt-2 text-xs text-green-500 font-bold";
                
                this.frame = 1;
                this.applyFrame();
                this.updateUI();
            }

            applyFrame() {
                if(!this.animData[this.frame]) return;
                const frameData = this.animData[this.frame];

                Object.keys(this.bones).forEach(idStr => {
                    const id = parseInt(idStr);
                    const bone = this.bones[id];
                    const data = frameData[id];

                    if(data) {
                        // Apply animation rotation
                        bone.quaternion.set(data.rot[0], data.rot[1], data.rot[2], data.rot[3]);
                        
                        // Apply animation position
                        bone.position.set(data.pos[0], data.pos[1], data.pos[2]);
                    }
                });
                
                // Update bone lines after applying animation
                this.updateBoneLines();
                
                // Update skeleton helper if it exists
                if (this.skeletonHelper) {
                    this.skeletonHelper.update();
                }
                
                // Update mesh skeleton if it exists
                if (this.mesh && this.mesh.skeleton) {
                    this.mesh.skeleton.update();
                }
            }

            togglePlay() {
                this.isPlaying = !this.isPlaying;
                this.updateUI();
            }

            updateUI() {
                const btn = document.getElementById('play-btn');
                btn.textContent = this.isPlaying ? "Pause" : "Play";
                btn.className = this.isPlaying ? "flex-1 bg-yellow-600 hover:bg-yellow-700 text-white py-2 rounded font-bold" : "flex-1 bg-green-600 hover:bg-green-700 text-white py-2 rounded font-bold";
                document.getElementById('current-frame').textContent = this.frame;
                document.getElementById('frame-slider').value = this.frame;
            }

            loop() {
                requestAnimationFrame(() => this.loop());
                this.renderer.render(this.scene, this.camera);
                
                if(this.isPlaying && this.totalFrames > 0) {
                    let next = this.frame + this.speed;
                    if(next > this.totalFrames) next = 1;
                    this.frame = Math.floor(next);
                    this.applyFrame();
                    this.updateUI();
                }
            }
        }

        lucide.createIcons();
        window.viewer = new AnimationViewer3D();
    </script>
</body>
</html>
