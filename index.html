<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Animation Editor V4 (Position Fix)</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/TransformControls.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #121212; font-family: 'Inter', 'Segoe UI', sans-serif; color: white; }
        #app-container { display: flex; height: 100vh; width: 100vw; overflow: hidden; position: relative; }
        #sidebar { width: 360px; min-width: 360px; background: #1e1e1e; border-right: 1px solid #333; display: flex; flex-direction: column; padding: 10px; z-index: 20; transition: margin-left 0.3s ease, min-width 0.3s ease; height: 100%; overflow-y: auto; margin-left: 0; position: relative; }
        #sidebar.collapsed { margin-left: -360px; min-width: 0; width: 0; padding: 0; border-right: none; }
        #sidebar-toggle { position: absolute; top: 50%; right: -24px; transform: translateY(-50%); width: 24px; height: 48px; background: #1e1e1e; border: 1px solid #333; border-left: none; border-radius: 0 8px 8px 0; cursor: pointer; display: flex; align-items: center; justify-content: center; color: #81d4fa; font-size: 12px; z-index: 21; transition: left 0.3s ease, margin-left 0.3s ease; }
        #sidebar.collapsed #sidebar-toggle { right: -24px; position: fixed; left: 0; transform: translateY(-50%); }
        #main-content { flex-grow: 1; display: flex; flex-direction: column; position: relative; background: #000; min-width: 0; }
        #canvas-wrapper { flex-grow: 1; position: relative; background: radial-gradient(circle at center, #1a1a1a 0%, #000000 100%); overflow: hidden; }
        #canvas-container { width: 100%; height: 100%; display: block; }
        #timeline-wrapper { height: 140px; min-height: 140px; background: #181818; border-top: 1px solid #333; display: flex; flex-direction: column; user-select: none; }
        #timeline-controls { height: 36px; background: #252525; display: flex; align-items: center; justify-content: center; gap: 15px; border-bottom: 1px solid #333; position: relative; }
        #time-display { position: absolute; right: 15px; font-family: monospace; font-size: 12px; color: #81d4fa; min-width: 120px; text-align: right; }
        .tc-btn { background: none; border: none; color: #ccc; cursor: pointer; font-size: 16px; padding: 4px 8px; border-radius: 4px; }
        .tc-btn:hover { background: #333; color: white; }
        .tc-btn.active { color: #81d4fa; }
        #timeline-canvas-container { flex-grow: 1; position: relative; overflow: hidden; background: #121212; cursor: pointer; }
        canvas#timeline-canvas { display: block; width: 100%; height: 100%; }
        .panel { background: #2a2a2a; border-radius: 6px; padding: 12px; margin-bottom: 12px; border: 1px solid #333; }
        .panel h3 { margin: 0 0 10px 0; font-size: 13px; color: #81d4fa; text-transform: uppercase; letter-spacing: 0.5px; border-bottom: 1px solid #444; padding-bottom: 5px; }
        .control-group { margin-bottom: 10px; display: flex; align-items: center; justify-content: space-between; font-size: 12px; }
        .control-group label { color: #aaa; }
        input[type="number"], input[type="text"] { width: 70px; background: #111; border: 1px solid #444; color: white; padding: 4px; border-radius: 3px; }
        button.action-btn { width: 100%; padding: 10px; background: #37474f; color: white; border: none; border-radius: 4px; cursor: pointer; margin-bottom: 6px; font-weight: 600; font-size: 12px; transition: all 0.2s; text-transform: uppercase; }
        button.action-btn:hover { background: #455a64; }
        button.action-btn:disabled { background: #222; color: #555; cursor: not-allowed; }
        button.primary { background: #0d47a1; }
        button.primary:hover { background: #1565c0; }
        button.success { background: #2e7d32; }
        button.success:hover { background: #388e3c; }
        button.mode-active { background: #ff8f00; color: #000; }
        button.mode-active:hover { background: #ffa000; }
        #load-area { border: 2px dashed #444; padding: 25px 10px; text-align: center; color: #888; border-radius: 8px; cursor: pointer; transition: 0.2s; font-size: 13px; }
        #load-area:hover { border-color: #0d47a1; color: white; background: rgba(13, 71, 161, 0.1); }
        #log-output { flex-grow: 1; min-height: 100px; background: #111; border: 1px solid #333; border-radius: 4px; overflow-y: auto; font-family: monospace; font-size: 11px; padding: 8px; color: #ccc; }
        .log-err { color: #ff5252; }
        .log-suc { color: #69f0ae; }
        .log-warn { color: #ffd740; }
    </style>
</head>
<body>

<div id="app-container">
    <div id="sidebar">
        <div id="sidebar-toggle" title="Toggle Sidebar">â—€</div>

        <div class="panel">
            <h3>1. File I/O</h3>
            <div id="load-area" onclick="document.getElementById('file-input').click()">
                <span style="font-size: 20px;">ðŸ“‚</span><br>Click to Load .bytes / .dat
            </div>
            <input type="file" id="file-input" style="display: none;">
        </div>

        <div class="panel">
            <h3>2. Editor Tools</h3>
            <button id="edit-mode-btn" class="action-btn">âœŽ Enter Edit Mode</button>
            <div style="display: flex; gap: 5px;">
                <button id="undo-btn" class="action-btn" disabled style="flex:1;">âŽŒ Undo (0)</button>
                <button onclick="testPositionCalculation()" class="action-btn" style="flex:1;">ðŸ§ª Test</button>
            </div>
            
            <div id="save-tools" style="display:none; margin-top:5px; padding-top:5px; border-top:1px dashed #444;">
                <button id="tick-btn" class="action-btn success">âœ” Commit Changes</button>
                <button id="export-btn" class="action-btn primary" style="display:none;">â¬‡ Export .bytes</button>
            </div>
            <div style="font-size: 11px; color: #666; margin-top: 5px; text-align: center;">
                <em>Select bone -> Move with Gizmo -> Undo if needed</em>
            </div>
        </div>

        <div class="panel">
            <h3>3. Settings</h3>
            <div class="control-group">
                <label>Pos Scale (Read):</label>
                <input type="number" id="scale-factor-input" value="100000.0" step="1.0">
            </div>
            <div class="control-group">
                <label>Export Multiplier (Write):</label>
                <input type="number" id="export-multiplier-input" value="1.0" step="0.1">
            </div>
            <div class="control-group">
                <label>Header Offset:</label>
                <input type="number" id="offset-input" value="0">
            </div>
            <div class="control-group">
                <label>Move Sensitivity:</label>
                <input type="number" id="move-sensitivity" value="1.0" step="0.1" min="0.1" max="10.0">
            </div>
            <button onclick="reparseCurrentBuffer()" class="action-btn" style="background:#444;">â†» Reload Data</button>
        </div>

        <div class="panel">
            <h3>Debug Controls</h3>
            <div class="control-group">
                <label>Manual X Offset:</label>
                <input type="number" id="debug-x" value="0" step="1">
            </div>
            <div class="control-group">
                <label>Manual Y Offset:</label>
                <input type="number" id="debug-y" value="0" step="1">
            </div>
            <div class="control-group">
                <label>Manual Z Offset:</label>
                <input type="number" id="debug-z" value="0" step="1">
            </div>
            <button onclick="applyManualOffset()" class="action-btn">Apply Manual Offset</button>
            <button onclick="debugBoneValues()" class="action-btn" style="margin-top:5px;">ðŸ“Š Debug Values</button>
        </div>

        <div class="panel" style="display:flex; flex-direction:column; flex-grow:1; margin-bottom:0;">
            <h3>System Log</h3>
            <div id="log-output"></div>
        </div>
    </div>
    
    <div id="main-content">
        <div id="canvas-wrapper">
            <div id="canvas-container"></div>
        </div>

        <div id="timeline-wrapper">
            <div id="timeline-controls">
                <button id="play-btn" class="tc-btn">â–¶</button>
                <button id="stop-btn" class="tc-btn">â—¼</button>
                <span id="time-display">Frame: 0</span>
            </div>
            <div id="timeline-canvas-container">
                <canvas id="timeline-canvas"></canvas>
            </div>
        </div>
    </div>
</div>

<script>
// ==========================================
// 1. CONSTANTS & GLOBALS
// ==========================================
const MAGIC_NUMBER_BIGINT = 457546134634734n;
const BONE_MAP = {
    0: "pelvis", 1: "stomach", 2: "chest", 3: "neck", 4: "head", 5: "hair", 6: "hair1",
    7: "zero_joint_hand_l", 8: "clavicle_l", 9: "arm_l", 10: "forearm_l",
    11: "forearm_twist_l", 12: "hand_l", 13: "weapon_l", 14: "f_big1_l", 15: "f_big2_l", 16: "f_big3_l",
    17: "f_main1_l", 18: "f_main2_l", 19: "f_main3_l", 20: "f_pointer1_l", 21: "f_pointer2_l", 22: "f_pointer3_l",
    23: "scapular_l", 24: "chest_l", 25: "zero_joint_hand_r", 26: "clavicle_r", 27: "arm_r", 28: "forearm_r",
    29: "forearm_twist_r", 30: "hand_r", 31: "weapons_r", 32: "f_big1_r", 33: "f_big2_r", 34: "f_big3_r",
    35: "f_main1_r", 36: "f_main2_r", 37: "f_main3_r", 38: "f_pointer1_r", 39: "f_pointer2_r", 40: "f_pointer3_r",
    41: "zero_joint_pelvis_l", 42: "thigh_l", 43: "calf_l", 44: "foot_l", 45: "toe_l", 46: "back_l",
    47: "zero_joint_pelvis_r", 48: "thigh_r", 49: "calf_r", 50: "foot_r", 51: "toe_r", 52: "back_r",
    53: "biceps_twist_l", 54: "biceps_twist_r", 55: "item_l", 56: "item_r",
    57: "thigh_twist_l", 58: "thigh_twist_r"
};

const DEFAULT_SKELETON_TXT = `
"pelvis" [BONE] | G.Pos:(-105.750, 80.938, -7.070)
  "zero_joint_pelvis_l" [BONE] | G.Pos:(-105.750, 80.938, -7.070)
    "thigh_l" [BONE] | G.Pos:(-114.096, 82.097, -10.787)
      "calf_l" [BONE] | G.Pos:(-148.211, 49.767, 3.287)
        "foot_l" [BONE] | G.Pos:(-152.879, 12.394, -13.223)
          "toe_l" [BONE] | G.Pos:(-165.312, 2.301, -0.156)
      "thigh_twist_l" [BONE] | G.Pos:(-126.585, 69.701, -6.025)
    "back_l" [BONE] | G.Pos:(-109.283, 77.661, -19.888)
  "stomach" [BONE] | G.Pos:(-105.452, 91.816, -5.262)
    "chest" [BONE] | G.Pos:(-104.960, 109.559, -5.274)
      "zero_joint_hand_l" [BONE] | G.Pos:(-104.960, 109.559, -5.274)
        "chest_l" [BONE] | G.Pos:(-123.178, 114.886, 4.693)
        "clavicle_l" [BONE] | G.Pos:(-111.292, 133.672, -3.881)
          "arm_l" [BONE] | G.Pos:(-124.895, 127.953, -14.988)
            "biceps_twist_l" [BONE] | G.Pos:(-129.133, 115.620, -19.839)
            "forearm_l" [BONE] | G.Pos:(-133.711, 102.290, -25.084)
              "hand_l" [BONE] | G.Pos:(-151.939, 93.721, -10.975)
                "f_big1_l" [BONE] | G.Pos:(-155.718, 97.132, -7.692)
                  "f_big2_l" [BONE] | G.Pos:(-157.912, 97.698, -4.502)
                    "f_big3_l" [BONE] | G.Pos:(-159.856, 94.621, -2.271)
                "f_pointer1_l" [BONE] | G.Pos:(-163.386, 95.563, -8.128)
                  "f_pointer2_l" [BONE] | G.Pos:(-163.214, 94.173, -3.901)
                    "f_pointer3_l" [BONE] | G.Pos:(-159.925, 95.151, -3.850)
                "weapon_l" [BONE] | G.Pos:(-159.918, 92.167, -6.401)
                "f_main1_l" [BONE] | G.Pos:(-162.706, 90.379, -9.055)
                  "f_main2_l" [BONE] | G.Pos:(-160.501, 90.364, -4.597)
                    "f_main3_l" [BONE] | G.Pos:(-156.227, 92.275, -5.487)
      "zero_joint_hand_r" [BONE] | G.Pos:(-104.960, 109.558, -5.274)
        "clavicle_r" [BONE] | G.Pos:(-107.850, 134.073, -1.510)
          "arm_r" [BONE] | G.Pos:(-94.099, 133.060, 10.778)
            "biceps_twist_r" [BONE] | G.Pos:(-85.253, 122.926, 14.328)
            "forearm_r" [BONE] | G.Pos:(-75.690, 111.971, 18.161)
              "hand_r" [BONE] | G.Pos:(-97.553, 103.356, 25.405)
                "weapon_r" [BONE] | G.Pos:(-106.350, 100.134, 24.666)
                "f_big1_r" [BONE] | G.Pos:(-93.684, 98.673, 29.832)
                  "f_big2_r" [BONE] | G.Pos:(-92.352, 98.711, 33.197)
                    "f_big3_r" [BONE] | G.Pos:(-91.248, 96.657, 34.694)
                "f_pointer1_r" [BONE] | G.Pos:(-95.957, 96.687, 29.815)
                  "f_pointer2_r" [BONE] | G.Pos:(-97.689, 95.275, 33.869)
                    "f_pointer3_r" [BONE] | G.Pos:(-99.648, 96.229, 34.425)
                "f_main1_r" [BONE] | G.Pos:(-99.168, 92.937, 27.696)
                  "f_main2_r" [BONE] | G.Pos:(-100.419, 93.308, 31.579)
                    "f_main3_r" [BONE] | G.Pos:(-102.399, 95.340, 31.905)
      "scapular_r" [BONE] | G.Pos:(-98.689, 139.613, 10.348)
      "chest_r" [BONE] | G.Pos:(-108.722, 116.571, 14.634)
    "neck" [BONE] | G.Pos:(-109.693, 138.257, -3.259)
      "head" [BONE] | G.Pos:(-114.417, 149.774, -0.739)
        "hair" [BONE] | G.Pos:(-114.417, 149.774, -0.739)
        "hair1" [BONE] | G.Pos:(-114.417, 149.774, -0.739)
    "zero_joint_pelvis_r" [BONE] | G.Pos:(-105.750, 80.938, -7.070)
      "thigh_r" [BONE] | G.Pos:(-97.404, 82.097, -10.787)
        "calf_r" [BONE] | G.Pos:(-63.289, 49.767, 3.287)
          "foot_r" [BONE] | G.Pos:(-58.621, 12.394, -13.223)
            "toe_r" [BONE] | G.Pos:(-46.188, 2.301, -0.156)
        "thigh_twist_r" [BONE] | G.Pos:(-78.915, 69.701, -6.025)
      "back_r" [BONE] | G.Pos:(-102.217, 77.661, -19.888)
`;

let scene, camera, renderer, controls, transformControl;
let boneMeshes = []; 
let skeletonLines = []; 
let boneObjects = []; 
let animationFrames = [];
let fileMetadata = {}; 
let isPlaying = false;
let isEditMode = false;
let currentFrame = 0;
let lastTime = 0;
let skeletonData = [];
let undoStack = [];
let loadedFileName = "animation.bytes";
const MAX_UNDO = 5;
let T_POSE_CENTER_OFFSET = new THREE.Vector3(0, 0, 0);
let moveSensitivity = 1.0;

// Timeline Vars
let tlCanvas, tlCtx;
let tlScale = 10; 
let tlScrollX = 0;
let isDraggingTimeline = false;

// ==========================================
// 2. PARSER & UTILS
// ==========================================
function log(msg, type="info") {
    const d = document.getElementById('log-output');
    const e = document.createElement('div');
    e.className = `log-${type}`;
    e.innerText = `> ${msg}`;
    d.appendChild(e);
    d.scrollTop = d.scrollHeight;
}

function readFloat16(view, offset, littleEndian, scale) {
    if(offset + 2 > view.byteLength) return 0;
    const shortValue = view.getInt16(offset, littleEndian);
    return shortValue / scale;
}

function float32ToRawInt16(value, scaleFactor, exportMultiplier) {
    const multipliedValue = value * exportMultiplier;
    
    let intVal = Math.round(multipliedValue * scaleFactor);

    if(intVal > 32767) intVal = 32767;
    if(intVal < -32768) intVal = -32768;
    
    return intVal;
}

let rawBuffer = null;

function reparseCurrentBuffer() {
    if(!rawBuffer) { log("No file loaded.", "err"); return; }
    try {
        const result = parseAnimationData(rawBuffer);
        animationFrames = result.frames;
        fileMetadata = result.metadata;
        
        currentFrame = 0;
        
        skeletonData = parseSkeletonText(DEFAULT_SKELETON_TXT); 
        buildSkeletonVisuals();
        
        updateSkeletonPose(0);
        
        undoStack = [];
        updateUndoBtn();
        
        drawTimeline();

        log(`Parse Successful! Loaded ${result.frames.length} frames.`, "suc");
    } catch(e) {
        log(e.message, "err");
    }
}

function parseAnimationData(buffer) {
    const view = new DataView(buffer);
    let offset = parseInt(document.getElementById('offset-input').value) || 0;
    const scaleFactor = parseFloat(document.getElementById('scale-factor-input').value) || 100000.0;
    
    const metadata = { header: 0n, garbageSize: 0, garbageData: null, boneCount: 0, boneIds: [], remainingData: null, headerOffset: offset };

    if (view.byteLength < offset + 14) throw new Error("File too short.");

    let readPtr = offset + 8;
    const garbageSize = view.getInt16(readPtr, true);
    metadata.garbageSize = garbageSize;
    readPtr += 2;
    if(garbageSize > 0) {
        metadata.garbageData = buffer.slice(readPtr, readPtr + (garbageSize * 8));
        readPtr += (garbageSize * 8);
    }

    let framesLength = view.getUint32(readPtr, true);
    readPtr += 4;
    
    const boneCount = view.getUint16(readPtr, true);
    metadata.boneCount = boneCount;
    readPtr += 2;

    for (let i = 0; i < boneCount; i++) {
        metadata.boneIds.push(view.getUint16(readPtr, true));
        readPtr += 2;
    }

    const frames = [];
    const frameSize = boneCount * 12;

    for (let f = 0; f < framesLength; f++) {
        if (readPtr + frameSize > buffer.byteLength) break;
        const frameData = {}; 
        for (let b = 0; b < boneCount; b++) {
            const posX = readFloat16(view, readPtr, true, scaleFactor);
            const posY = readFloat16(view, readPtr + 2, true, scaleFactor);
            const posZ = readFloat16(view, readPtr + 4, true, scaleFactor);
            const rotBytes = buffer.slice(readPtr + 6, readPtr + 12);
            const boneId = metadata.boneIds[b];
            
            const vec = new THREE.Vector3(posX, posY, posZ);
            vec.userData = { rotBytes: new Uint8Array(rotBytes) };
            frameData[boneId] = vec;
            readPtr += 12;
        }
        frames.push(frameData);
    }
    if(readPtr < buffer.byteLength) metadata.remainingData = buffer.slice(readPtr);
    return { frames, metadata };
}

// ==========================================
// 3. 3D VIEWER
// ==========================================
function initViewer() {
    const container = document.getElementById('canvas-container');
    const width = container.clientWidth;
    const height = container.clientHeight;

    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x111111);

    camera = new THREE.PerspectiveCamera(60, width / height, 0.1, 1000);
    camera.position.set(0, 100, 400);

    renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(width, height);
    renderer.setPixelRatio(window.devicePixelRatio);
    container.appendChild(renderer.domElement);
    
    controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.target.set(0, 100, 0);
    controls.enableDamping = true;
    
    transformControl = new THREE.TransformControls(camera, renderer.domElement);
    
    // FIXED EVENT HANDLERS
    transformControl.addEventListener('objectChange', () => {
        if (transformControl.object && !transformControl.dragging) {
            console.log("Transform control changed - object:", transformControl.object.name);
            updateBoneFromTransform(transformControl.object);
        }
    });

    transformControl.addEventListener('dragging-changed', (event) => {
        controls.enabled = !event.value;
        console.log("Dragging changed:", event.value);
        
        if (!event.value && transformControl.object) {
            console.log("Drag ended - recording undo");
            recordUndo();
            updateBoneFromTransform(transformControl.object);
            updateSkeletonPose(currentFrame);
        }
    });
    
    scene.add(transformControl);

    scene.add(new THREE.GridHelper(500, 50, 0x444444, 0x222222));
    scene.add(new THREE.AxesHelper(50));
    const light = new THREE.DirectionalLight(0xffffff, 1);
    light.position.set(50, 200, 100);
    scene.add(light);
    scene.add(new THREE.AmbientLight(0xffffff, 0.6));

    window.addEventListener('resize', onWindowResize, false);
    
    skeletonData = parseSkeletonText(DEFAULT_SKELETON_TXT);
    buildSkeletonVisuals();
    
    setupUI();
    initTimeline();
    
    requestAnimationFrame(animate);
}

function onWindowResize() {
    const wrapper = document.getElementById('canvas-wrapper');
    const w = wrapper.clientWidth;
    const h = wrapper.clientHeight;
    
    camera.aspect = w / h;
    camera.updateProjectionMatrix();
    
    renderer.setSize(w, h);
    
    resizeTimeline();
}

const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();

document.getElementById('canvas-container').addEventListener('pointerdown', (event) => {
    if(!isEditMode) return;
    const rect = renderer.domElement.getBoundingClientRect();
    mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
    mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
    
    raycaster.setFromCamera(mouse, camera);
    const intersects = raycaster.intersectObjects(boneMeshes);

    if (intersects.length > 0) {
        const boneObject = intersects[0].object.userData.boneObject;
        if (boneObject) selectNode(boneObject);
    } else if (!transformControl.dragging) {
        deselectNode();
    }
});

function selectNode(boneObject) {
    boneMeshes.forEach(n => n.material.color.setHex(0x00ff00));
    const meshToHighlight = boneMeshes.find(m => m.userData.boneId === boneObject.userData.boneId);
    if(meshToHighlight) meshToHighlight.material.color.setHex(0x0088ff);
    
    transformControl.attach(boneObject);
    console.log("Selected bone:", boneObject.name, "ID:", boneObject.userData.boneId);
}

function deselectNode() {
    transformControl.detach();
    boneMeshes.forEach(n => n.material.color.setHex(0x00ff00));
}

function parseSkeletonText(txt) {
    const lines = txt.split('\n');
    const skel = [];
    const globalPositions = [];
    let minX = Infinity, minY = Infinity, minZ = Infinity;
    let maxX = -Infinity, maxY = -Infinity, maxZ = -Infinity;

    lines.forEach(line => {
        if(!line.trim()) return;
        const nameMatch = line.match(/"([^"]+)"/);
        const posMatch = line.match(/G\.Pos:\(([^,]+),\s*([^,]+),\s*([^)]+)\)/);
        
        if(nameMatch && posMatch) {
            const name = nameMatch[1];
            const globalPos = new THREE.Vector3(parseFloat(posMatch[1]), parseFloat(posMatch[2]), parseFloat(posMatch[3]));
            const boneId = Object.entries(BONE_MAP).find(([id, val]) => val === name)?.[0];
            
            minX = Math.min(minX, globalPos.x); maxX = Math.max(maxX, globalPos.x);
            minY = Math.min(minY, globalPos.y); maxY = Math.max(maxY, globalPos.y);
            minZ = Math.min(minZ, globalPos.z); maxZ = Math.max(maxZ, globalPos.z);
            
            const node = {
                name: name,
                boneId: boneId ? parseInt(boneId) : -1,
                parentIndex: -1,
                initialGlobalPos: globalPos.clone()
            };
            
            skel.push(node);
            globalPositions.push(globalPos);
        }
    });

    T_POSE_CENTER_OFFSET = new THREE.Vector3(
        (minX + maxX) / 2, 
        (minY + maxY) / 2, 
        (minZ + maxZ) / 2
    );
    log(`T-Pose Center Calculated: (${T_POSE_CENTER_OFFSET.x.toFixed(2)}, ${T_POSE_CENTER_OFFSET.y.toFixed(2)}, ${T_POSE_CENTER_OFFSET.z.toFixed(2)})`, "info");
    
    skel.forEach(bone => {
        bone.initialLocalPos = bone.initialGlobalPos.clone().sub(T_POSE_CENTER_OFFSET);
    });
    
    let tempStack = [];
    lines.forEach(line => {
        if(!line.trim()) return;
        const indent = line.match(/^(\s*)/)[1].length / 2;
        const nameMatch = line.match(/"([^"]+)"/);
        
        if(nameMatch) {
            const name = nameMatch[1];
            const boneIndex = skel.findIndex(b => b.name === name);
            if(boneIndex === -1) return;
            
            if(indent > 0) {
                while(tempStack.length > indent) tempStack.pop();
                if(tempStack.length > 0) skel[boneIndex].parentIndex = tempStack[tempStack.length-1];
            } else tempStack = [];
            
            tempStack.push(boneIndex);
        }
    });
    
    return skel;
}

function buildSkeletonVisuals() {
    boneObjects.forEach(obj => { if (obj.parent) obj.parent.remove(obj); });
    boneMeshes.forEach(mesh => scene.remove(mesh));
    skeletonLines.forEach(line => scene.remove(line));

    boneMeshes = [];
    boneObjects = [];
    skeletonLines = [];
    
    const geo = new THREE.SphereGeometry(2.0, 8, 8);
    const mat = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
    const lineMat = new THREE.LineBasicMaterial({ color: 0xcccccc, transparent: true, opacity: 0.8 });

    const root = new THREE.Object3D();
    root.name = "SkeletonRoot";
    root.position.copy(T_POSE_CENTER_OFFSET);
    scene.add(root);

    skeletonData.forEach((bone, i) => {
        const boneObj = new THREE.Object3D();
        boneObj.name = bone.name;
        boneObj.position.copy(bone.initialLocalPos);
        boneObj.userData = { ...bone };
        boneObjects.push(boneObj);

        root.add(boneObj);
        
        const mesh = new THREE.Mesh(geo, mat.clone());
        mesh.userData.boneId = bone.boneId;
        mesh.userData.boneObject = boneObj;
        boneObj.add(mesh);
        boneMeshes.push(mesh);
        
        if(bone.parentIndex !== -1) {
            const parentObj = boneObjects[bone.parentIndex];
            const lineGeo = new THREE.BufferGeometry().setFromPoints([parentObj.position, boneObj.position]);
            const line = new THREE.Line(lineGeo, lineMat);
            line.userData = { parentObj: parentObj, childObj: boneObj };
            root.add(line);
            skeletonLines.push(line);
        }
    });
}

// FIXED POSITION UPDATE FUNCTION
function updateBoneFromTransform(boneObj) {
    if(!animationFrames[currentFrame]) return;
    const id = boneObj.userData.boneId;
    
    console.log("=== BONE TRANSFORM UPDATE ===");
    console.log("Bone ID:", id, "Name:", boneObj.name);
    console.log("Current bone position:", boneObj.position.toArray());
    console.log("Initial local pos:", boneObj.userData.initialLocalPos.toArray());
    
    const newPosRelativeToCenter = boneObj.position.clone();
    const initialLocalPos = boneObj.userData.initialLocalPos.clone();
    const newAnimOffset = newPosRelativeToCenter.sub(initialLocalPos);
    
    console.log("Calculated animation offset:", newAnimOffset.toArray());
    console.log("Offset magnitude:", newAnimOffset.length());
    
    const existing = animationFrames[currentFrame][id];
    if(existing && existing.userData.rotBytes) {
        newAnimOffset.userData = { rotBytes: existing.userData.rotBytes };
    }

    animationFrames[currentFrame][id] = newAnimOffset;
    console.log("Stored in animation frame:", animationFrames[currentFrame][id].toArray());
    
    // Force immediate visual update
    updateSkeletonPose(currentFrame);
}

function updateSkeletonPose(frameIdx) {
    if(!animationFrames[frameIdx]) return;
    const frameData = animationFrames[frameIdx];

    boneObjects.forEach(boneObj => {
        const id = boneObj.userData.boneId;
        const initialLocalPos = boneObj.userData.initialLocalPos.clone();
        
        if(transformControl.object === boneObj && transformControl.dragging) return;
        
        let finalLocalPos = initialLocalPos.clone();
        
        if(frameData[id]) {
            finalLocalPos.add(frameData[id]);
        }
        
        boneObj.position.copy(finalLocalPos);
    });
    
    scene.updateMatrixWorld(true);
    updateLines();
}

function updateLines() {
    skeletonLines.forEach(line => {
        const pObj = line.userData.parentObj;
        const cObj = line.userData.childObj;
        
        const pos = line.geometry.attributes.position.array;
        
        pos[0]=pObj.position.x; 
        pos[1]=pObj.position.y; 
        pos[2]=pObj.position.z;
        
        pos[3]=cObj.position.x; 
        pos[4]=cObj.position.y; 
        pos[5]=cObj.position.z;
        
        line.geometry.attributes.position.needsUpdate = true;
    });
}

function animate(time) {
    requestAnimationFrame(animate);
    controls.update();
    if(isPlaying && animationFrames.length > 0) {
        if(time - lastTime > (1000/30)) {
            currentFrame = (currentFrame + 1) % animationFrames.length;
            updateUIForFrame(currentFrame);
            lastTime = time;
        }
    }
    renderer.render(scene, camera);
}

// ==========================================
// 4. TIMELINE LOGIC
// ==========================================
function initTimeline() {
    tlCanvas = document.getElementById('timeline-canvas');
    tlCtx = tlCanvas.getContext('2d');
    tlCanvas.addEventListener('mousedown', onTlMouseDown);
    window.addEventListener('mouseup', onTlMouseUp);
    window.addEventListener('mousemove', onTlMouseMove);
    tlCanvas.addEventListener('wheel', (e) => {
        e.preventDefault();
        tlScale += e.deltaY * -0.01;
        if(tlScale < 1) tlScale = 1;
        if(tlScale > 50) tlScale = 50;
        drawTimeline();
    });
    resizeTimeline();
}

function resizeTimeline() {
    const container = document.getElementById('timeline-canvas-container');
    tlCanvas.width = container.clientWidth;
    tlCanvas.height = container.clientHeight;
    drawTimeline();
}

function drawTimeline() {
    const w = tlCanvas.width;
    const h = tlCanvas.height;
    const totalFrames = animationFrames.length || 0;
    
    tlCtx.fillStyle = '#1e1e1e';
    tlCtx.fillRect(0, 0, w, h);
    
    if(totalFrames === 0) return;

    tlCtx.fillStyle = '#252525';
    tlCtx.fillRect(0, 0, w, 25);
    tlCtx.strokeStyle = '#555';
    tlCtx.lineWidth = 1;
    tlCtx.beginPath();
    tlCtx.moveTo(0, 25); tlCtx.lineTo(w, 25);
    tlCtx.stroke();

    const startFrame = Math.floor(tlScrollX / tlScale);
    const endFrame = startFrame + Math.ceil(w / tlScale) + 1;

    for (let f = startFrame; f < endFrame; f++) {
        if (f < 0 || f >= totalFrames) continue;
        const x = (f * tlScale) - tlScrollX;
        
        if (f % 5 === 0) {
            tlCtx.strokeStyle = '#888';
            tlCtx.beginPath();
            tlCtx.moveTo(x, 0); tlCtx.lineTo(x, 25);
            tlCtx.stroke();
            
            tlCtx.fillStyle = '#ccc';
            tlCtx.font = '10px monospace';
            tlCtx.fillText(f.toString(), x + 4, 15);
        } else {
            tlCtx.strokeStyle = '#444';
            tlCtx.beginPath();
            tlCtx.moveTo(x, 15); tlCtx.lineTo(x, 25);
            tlCtx.stroke();
        }

        if (isEditMode) {
            tlCtx.fillStyle = '#2e7d32';
            tlCtx.fillRect(x + 1, 30, tlScale - 2, 40);
        } else {
            tlCtx.fillStyle = '#37474f';
            tlCtx.fillRect(x + 1, 30, tlScale - 2, 40);
        }
    }

    const playheadX = (currentFrame * tlScale) - tlScrollX;
    
    tlCtx.strokeStyle = '#ff5252';
    tlCtx.lineWidth = 2;
    tlCtx.beginPath();
    tlCtx.moveTo(playheadX, 0); 
    tlCtx.lineTo(playheadX, h);
    tlCtx.stroke();

    tlCtx.fillStyle = '#ff5252';
    tlCtx.beginPath();
    tlCtx.moveTo(playheadX - 6, 0);
    tlCtx.lineTo(playheadX + 6, 0);
    tlCtx.lineTo(playheadX, 10);
    tlCtx.fill();
}

function onTlMouseDown(e) {
    isDraggingTimeline = true;
    updateTimelineFromMouse(e);
}
function onTlMouseUp(e) {
    isDraggingTimeline = false;
}
function onTlMouseMove(e) {
    if(isDraggingTimeline) {
        updateTimelineFromMouse(e);
    }
}
function updateTimelineFromMouse(e) {
    const rect = tlCanvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const clickedFrame = Math.floor((x + tlScrollX) / tlScale);
    
    if(clickedFrame >= 0 && clickedFrame < animationFrames.length) {
        currentFrame = clickedFrame;
        isPlaying = false;
        updateUIForFrame(currentFrame);
    }
}

function updateUIForFrame(f) {
    document.getElementById('time-display').innerText = `Frame: ${f} / ${animationFrames.length-1}`;
    
    const w = tlCanvas.width;
    const playheadX = (f * tlScale) - tlScrollX;
    
    if (playheadX > w * 0.8) {
        tlScrollX = (f * tlScale) - (w * 0.5);
    } else if (playheadX < w * 0.2) {
        tlScrollX = (f * tlScale) - (w * 0.5);
    }
    if(tlScrollX < 0) tlScrollX = 0;
    
    drawTimeline();
    updateSkeletonPose(f);
}

// ==========================================
// 5. DEBUG & FIX FUNCTIONS
// ==========================================
function applyManualOffset() {
    if (!transformControl.object) {
        log("No bone selected", "err");
        return;
    }
    
    const x = parseFloat(document.getElementById('debug-x').value);
    const y = parseFloat(document.getElementById('debug-y').value);
    const z = parseFloat(document.getElementById('debug-z').value);
    
    const offset = new THREE.Vector3(x, y, z);
    transformControl.object.position.add(offset);
    
    updateBoneFromTransform(transformControl.object);
    updateSkeletonPose(currentFrame);
    
    console.log("Applied manual offset:", offset.toArray());
    log(`Applied manual offset: (${x}, ${y}, ${z})`, "info");
}

function debugBoneValues() {
    if (!animationFrames[currentFrame]) return;
    
    console.log("=== CURRENT FRAME BONE VALUES ===");
    Object.entries(animationFrames[currentFrame]).forEach(([boneId, vec]) => {
        const boneName = BONE_MAP[boneId] || `Bone_${boneId}`;
        console.log(`${boneName}: (${vec.x.toFixed(6)}, ${vec.y.toFixed(6)}, ${vec.z.toFixed(6)})`);
        
        const SCALE_FACTOR = parseFloat(document.getElementById('scale-factor-input').value) || 100000.0;
        const EXPORT_MULTIPLIER = parseFloat(document.getElementById('export-multiplier-input').value) || 1.0;
        
        const exportX = float32ToRawInt16(vec.x, SCALE_FACTOR, EXPORT_MULTIPLIER);
        const exportY = float32ToRawInt16(vec.y, SCALE_FACTOR, EXPORT_MULTIPLIER);
        const exportZ = float32ToRawInt16(vec.z, SCALE_FACTOR, EXPORT_MULTIPLIER);
        
        console.log(`  -> Export: (${exportX}, ${exportY}, ${exportZ})`);
    });
}

function testPositionCalculation() {
    if (!transformControl.object) {
        log("No bone selected for test", "err");
        return;
    }
    
    const boneObj = transformControl.object;
    const id = boneObj.userData.boneId;
    
    console.log("=== POSITION CALCULATION TEST ===");
    
    // Method 1: Current method
    const currentPos = boneObj.position.clone();
    const initialPos = boneObj.userData.initialLocalPos.clone();
    const offset1 = currentPos.sub(initialPos);
    
    console.log("Method 1 - Current - Initial:", offset1.toArray());
    
    // Method 2: Direct assignment
    const offset2 = boneObj.position.clone();
    
    console.log("Method 2 - Direct position:", offset2.toArray());
    
    // Test which one works
    const testOffset = new THREE.Vector3(10, 0, 0); // Test with 10 units on X
    animationFrames[currentFrame][id] = testOffset.clone();
    
    if(animationFrames[currentFrame][id].userData && animationFrames[currentFrame][id].userData.rotBytes) {
        testOffset.userData = { rotBytes: animationFrames[currentFrame][id].userData.rotBytes };
    }
    
    updateSkeletonPose(currentFrame);
    console.log("Applied test offset (10,0,0) - check if bone moved");
    log("Applied test offset (10,0,0) - check visual", "info");
}

// ==========================================
// 6. APP LOGIC
// ==========================================
function toggleEditMode() {
    isEditMode = !isEditMode;
    const btn = document.getElementById('edit-mode-btn');
    const saveTools = document.getElementById('save-tools');

    if(isEditMode) {
        btn.classList.add('mode-active');
        btn.innerText = "âœŽ EXIT EDIT MODE";
        saveTools.style.display = 'block';
        isPlaying = false;
        log("Edit Mode Enabled.", "info");
    } else {
        btn.classList.remove('mode-active');
        btn.innerText = "âœŽ ENTER EDIT MODE";
        saveTools.style.display = 'none';
        deselectNode();
        log("Edit Mode Disabled.", "info");
    }
    drawTimeline();
}

function recordUndo() {
    const frameSnapshot = {};
    const frameData = animationFrames[currentFrame];
    for(let key in frameData) {
        const vec = frameData[key].clone();
        vec.userData = { ...frameData[key].userData };
        frameSnapshot[key] = vec;
    }
    undoStack.push({ frameIndex: currentFrame, data: frameSnapshot });
    if(undoStack.length > MAX_UNDO) undoStack.shift();
    updateUndoBtn();
}

function performUndo() {
    if(undoStack.length === 0) return;
    const action = undoStack.pop();
    animationFrames[action.frameIndex] = action.data;
    if(currentFrame === action.frameIndex) {
        updateSkeletonPose(currentFrame);
        if(transformControl.object) transformControl.attach(transformControl.object);
    }
    updateUndoBtn();
    log("Undo performed.", "info");
}

function updateUndoBtn() {
    const btn = document.getElementById('undo-btn');
    btn.innerText = `âŽŒ Undo (${undoStack.length})`;
    btn.disabled = undoStack.length === 0;
}

function saveProgress() {
    document.getElementById('export-btn').style.display = 'inline-block';
    log("Changes committed. Ready to Export.", "suc");
}

function exportBytes() {
    if(!rawBuffer) return;
    try {
        const buffer = reconstructBinary();
        const blob = new Blob([buffer], {type: "application/octet-stream"});
        const link = document.createElement('a');
        link.href = URL.createObjectURL(blob);
        link.download = "edited_" + loadedFileName;
        link.click();
        log("Export successful!", "suc");
    } catch(e) {
        log("Export Failed: " + e.message, "err");
    }
}

function reconstructBinary() {
    const SCALE_FACTOR = parseFloat(document.getElementById('scale-factor-input').value) || 100000.0;
    const EXPORT_MULTIPLIER = parseFloat(document.getElementById('export-multiplier-input').value) || 1.0;
    
    const headerSize = 8;
    const garbageLenSize = 2;
    const garbageDataSize = fileMetadata.garbageSize * 8;
    const metaSize = 4 + 2 + (fileMetadata.boneCount * 2);
    const frameSize = fileMetadata.boneCount * 12;
    const animDataSize = animationFrames.length * frameSize;
    const footerSize = fileMetadata.remainingData ? fileMetadata.remainingData.byteLength : 0;
    
    const totalSize = fileMetadata.headerOffset + headerSize + garbageLenSize + garbageDataSize + metaSize + animDataSize + footerSize;
    const buffer = new ArrayBuffer(totalSize);
    const view = new DataView(buffer);
    
    let ptr = 0;
    if(fileMetadata.headerOffset > 0 && rawBuffer) {
        new Uint8Array(buffer).set(new Uint8Array(rawBuffer.slice(0, fileMetadata.headerOffset)), 0);
        ptr += fileMetadata.headerOffset;
    }

    view.setBigUint64(ptr, fileMetadata.header || MAGIC_NUMBER_BIGINT, true); ptr += 8;
    view.setInt16(ptr, fileMetadata.garbageSize, true); ptr += 2;
    if(fileMetadata.garbageData) {
        new Uint8Array(buffer).set(new Uint8Array(fileMetadata.garbageData), ptr);
        ptr += garbageDataSize;
    }

    view.setUint32(ptr, animationFrames.length, true); ptr += 4;
    view.setUint16(ptr, fileMetadata.boneCount, true); ptr += 2;

    fileMetadata.boneIds.forEach(id => { view.setUint16(ptr, id, true); ptr += 2; });

    animationFrames.forEach(frame => {
        fileMetadata.boneIds.forEach(id => {
            const vec = frame[id];
            const x = vec ? vec.x : 0;
            const y = vec ? vec.y : 0;
            const z = vec ? vec.z : 0;
            
            view.setInt16(ptr, float32ToRawInt16(x, SCALE_FACTOR, EXPORT_MULTIPLIER), true);
            view.setInt16(ptr+2, float32ToRawInt16(y, SCALE_FACTOR, EXPORT_MULTIPLIER), true);
            view.setInt16(ptr+4, float32ToRawInt16(z, SCALE_FACTOR, EXPORT_MULTIPLIER), true);
            ptr += 6;
            
            if(vec && vec.userData.rotBytes) new Uint8Array(buffer).set(vec.userData.rotBytes, ptr);
            else for(let k=0; k<6; k++) view.setUint8(ptr+k, 0);
            ptr += 6;
        });
    });

    if(fileMetadata.remainingData) new Uint8Array(buffer).set(new Uint8Array(fileMetadata.remainingData), ptr);
    return buffer;
}

function setupUI() {
    document.getElementById('file-input').addEventListener('change', e=>{
        const file = e.target.files[0];
        if(!file) return;
        loadedFileName = file.name;
        const reader = new FileReader();
        reader.onload = evt => {
            rawBuffer = evt.target.result;
            document.getElementById('offset-input').value = 0;
            reparseCurrentBuffer();
        };
        reader.readAsArrayBuffer(file);
    });

    document.getElementById('play-btn').addEventListener('click', ()=>{
        isPlaying = !isPlaying;
        document.getElementById('play-btn').innerText = isPlaying ? "â—¼" : "â–¶";
    });
    
    document.getElementById('stop-btn').addEventListener('click', ()=>{
        isPlaying = false;
        currentFrame = 0;
        updateUIForFrame(0);
        document.getElementById('play-btn').innerText = "â–¶";
    });

    document.getElementById('sidebar-toggle').addEventListener('click', ()=>{
        const sidebar = document.getElementById('sidebar');
        sidebar.classList.toggle('collapsed');
        
        const btn = document.getElementById('sidebar-toggle');
        btn.innerText = sidebar.classList.contains('collapsed') ? "â–¶" : "â—€";
        
        setTimeout(onWindowResize, 350);
    });

    document.getElementById('edit-mode-btn').addEventListener('click', toggleEditMode);
    document.getElementById('undo-btn').addEventListener('click', performUndo);
    document.getElementById('tick-btn').addEventListener('click', saveProgress);
    document.getElementById('export-btn').addEventListener('click', exportBytes);
    
    document.getElementById('scale-factor-input').addEventListener('change', reparseCurrentBuffer);
    document.getElementById('offset-input').addEventListener('change', reparseCurrentBuffer);
    
    document.getElementById('move-sensitivity').addEventListener('change', (e) => {
        moveSensitivity = parseFloat(e.target.value);
        console.log("Move sensitivity set to:", moveSensitivity);
    });
}

document.addEventListener('DOMContentLoaded', initViewer);
</script>
</body>
</html>
