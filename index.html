<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Skeletal Animation Compensator Tool V3</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1f2937;
            color: #f3f4f6;
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }
        .container {
            background: #374151;
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.4);
            width: 100%;
            max-width: 550px;
            border: 1px solid #4b5563;
        }
        h2 {
            color: #f59e0b; /* Amber Accent */
            text-align: center;
            margin-bottom: 25px;
            font-size: 1.5rem;
        }
        .control-group {
            margin-bottom: 20px;
            padding: 15px;
            background: #4b5563;
            border-radius: 8px;
        }
        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #d1d5db;
            font-size: 0.9rem;
        }
        input[type="file"], input[type="number"], button {
            width: 100%;
            padding: 12px;
            margin-top: 5px;
            border-radius: 6px;
            border: 1px solid #6b7280;
            box-sizing: border-box;
            font-size: 14px;
        }
        input[type="number"] {
            background-color: #1f2937;
            color: #f3f4f6;
        }
        input[type="file"] {
            background-color: #374151;
            color: #f3f4f6;
            cursor: pointer;
        }
        button {
            background-color: #f59e0b;
            color: white;
            cursor: pointer;
            transition: background-color 0.3s;
            font-weight: bold;
            text-transform: uppercase;
        }
        button:hover:not(:disabled) {
            background-color: #d97706;
        }
        button:disabled {
            background-color: #6b7280;
            cursor: not-allowed;
        }
        #status {
            margin-top: 25px;
            padding: 15px;
            border-radius: 8px;
            font-weight: 600;
            display: none;
            text-align: center;
        }
        .status-success { background: #059669; }
        .status-info { background: #3b82f6; }
        .status-error { background: #ef4444; }
    </style>
</head>
<body>

<div class="container">
    <h2>Bind Pose Compensation Utility V3 (Simplified)</h2>
    <p style="font-size: 14px; text-align: center; color: #9ca3af; margin-bottom: 20px;">Uses direct quaternion and vector subtraction for maximum compatibility with simplified engines.</p>

    <div class="control-group">
        <label for="skeletonInput">1. Original Skeleton Bind Pose (.txt)</label>
        <input type="file" id="skeletonInput" accept=".txt" />
    </div>

    <div class="control-group">
        <label for="csvInput">2. Animation Data (Local Transform) (.csv)</label>
        <input type="file" id="csvInput" accept=".csv" />
    </div>

    <div class="control-group">
        <label for="frameNumber">3. Frame Number to Compensate Against</label>
        <input type="number" id="frameNumber" min="1" value="1" placeholder="e.g., 50" />
        <p style="font-size: 12px; margin-top: 5px; color: #9ca3af;">Max loaded frame: <span id="maxFrame">N/A</span></p>
    </div>

    <button id="processBtn" disabled>Process & Download Compensated Skeleton</button>

    <div id="status" class="status-info" style="display: none;"></div>
</div>

<script>
    // ==========================================
    // 1. CONSTANTS AND DATA STRUCTURES
    // ==========================================

    // The bone map is essential for linking the animation CSV (by ID) to the skeleton TXT (by Name)
    const BONE_MAP = {
        0: "pelvis", 1: "stomach", 2: "chest", 3: "neck", 4: "head", 5: "hair", 6: "hair1",
        7: "zero_joint_hand_l", 8: "clavicle_l", 9: "arm_l", 10: "forearm_l",
        11: "forearm_twist_l", 12: "hand_l", 13: "weapon_l", 14: "f_big1_l", 15: "f_big2_l", 16: "f_big3_l",
        17: "f_main1_l", 18: "f_main2_l", 19: "f_main3_l", 20: "f_pointer1_l", 21: "f_pointer2_l", 22: "f_pointer3_l",
        23: "scapular_l", 24: "chest_l", 25: "zero_joint_hand_r", 26: "clavicle_r", 27: "arm_r", 28: "forearm_r",
        29: "forearm_twist_r", 30: "hand_r", 31: "weapon_r", 32: "f_big1_r", 34: "f_big3_r",
        35: "f_main1_r", 36: "f_main2_r", 37: "f_main3_r", 38: "f_pointer1_r", 39: "f_pointer2_r", 40: "f_pointer3_r",
        41: "scapular_r", 42: "chest_r", 43: "zero_joint_pelvis_l", 44: "thigh_l", 45: "calf_l", 46: "thigh_twist_l",
        47: "foot_l", 48: "toe_l", 49: "zero_joint_pelvis_r", 50: "thigh_r", 51: "calf_r", 52: "thigh_twist_r",
        53: "foot_r", 54: "toe_r", 55: "back_l", 56: "back_r", 57: "camera_target",
        58: "biceps_twist_l", 59: "biceps_twist_r", 33: "f_big2_r"
    };

    const NAME_TO_ID = Object.entries(BONE_MAP).reduce((acc, [id, name]) => {
        acc[name] = parseInt(id);
        return acc;
    }, {});

    // Global state
    let originalSkeletonLines = [];     
    let hierarchy = {};                 // Map: boneName -> parentName
    let originalLocalTransforms = {};   // T_bind (Original Local Bind Pose)
    let animationData = {};             // T_frame (Animation Local Transform)
    let maxLoadedFrame = 0;

    // UI elements
    const ui = {
        skeletonInput: document.getElementById('skeletonInput'),
        csvInput: document.getElementById('csvInput'),
        frameNumber: document.getElementById('frameNumber'),
        processBtn: document.getElementById('processBtn'),
        status: document.getElementById('status'),
        maxFrame: document.getElementById('maxFrame')
    };

    // ==========================================
    // 2. HELPER FUNCTIONS
    // ==========================================

    function setStatus(message, type = 'info') {
        ui.status.textContent = message;
        ui.status.className = `status-${type}`;
        ui.status.style.display = 'block';
    }

    function checkReady() {
        const skeletonReady = Object.keys(originalLocalTransforms).length > 0;
        const animationReady = Object.keys(animationData).length > 0;
        const ready = skeletonReady && animationReady;
        ui.processBtn.disabled = !ready;
        if (ready) {
            setStatus('Ready to process. Enter frame number and click the button.', 'info');
        } else if (skeletonReady) {
            setStatus('Load animation CSV to continue.', 'info');
        } else {
            ui.status.style.display = 'none';
        }
    }
    
    // ==========================================
    // 3. PARSING LOGIC (Identical to V2, as this is correct)
    // ==========================================

    /**
     * Parses the skeleton TXT file to derive Original Local Bind Pose (T_bind).
     */
    function parseSkeleton(skeletonText) {
        setStatus('Parsing skeleton file and calculating T_bind...', 'info');
        
        originalSkeletonLines = skeletonText.split('\n');
        originalLocalTransforms = {};
        hierarchy = {};
        
        // Cache to store the GLOBAL matrix of each bone as it is processed
        const globalTransformsCache = { 'root': new THREE.Matrix4() };
        const stack = []; // Stores { name, level, globalMatrix }

        originalSkeletonLines.forEach(line => {
            if (!line.trim()) return;
            const leadingSpaces = line.search(/\S/);
            const level = leadingSpaces / 2;
            const boneMatch = line.match(/"(.*?)"\s*\[(BONE|Group)\]/);
            const globalMatch = line.match(/G\.Pos:\((.*?)\)\s*\|\s*G\.Rot \(quat\):\((.*?)\)/);

            if (!boneMatch || !globalMatch) return;
            
            const name = boneMatch[1];
            
            // 1. Get Original Global Transform (T_global)
            const posArr = globalMatch[1].split(',').map(Number);
            const rotArr = globalMatch[2].split(',').map(Number);

            const globalPos = new THREE.Vector3(posArr[0], posArr[1], posArr[2]);
            const globalRot = new THREE.Quaternion(rotArr[0], rotArr[1], rotArr[2], rotArr[3]);
            const T_global = new THREE.Matrix4().compose(globalPos, globalRot, new THREE.Vector3(1, 1, 1));

            // 2. Determine Parent and Parent Global Transform (T_parent_global)
            let parentGlobalMatrix = globalTransformsCache['root'];

            while (stack.length > 0 && stack[stack.length - 1].level >= level) {
                stack.pop();
            }

            if (stack.length > 0) {
                const parentData = stack[stack.length - 1];
                hierarchy[name] = parentData.name;
                parentGlobalMatrix = parentData.globalMatrix;
            } else {
                hierarchy[name] = null; // Root bone
            }
            
            // 3. Calculate Original Local Bind Pose (T_bind) = T_parent_global^-1 * T_global
            const T_parent_global_inv = parentGlobalMatrix.clone().invert();
            const T_bind = T_parent_global_inv.multiply(T_global);
            
            const localPos = new THREE.Vector3();
            const localRot = new THREE.Quaternion();
            T_bind.decompose(localPos, localRot, new THREE.Vector3());
            
            originalLocalTransforms[name] = { pos: localPos, rot: localRot };

            // Update cache and stack
            globalTransformsCache[name] = T_global;
            stack.push({ name, level, globalMatrix: T_global });
        });
        
        setStatus(`Skeleton loaded. ${Object.keys(originalLocalTransforms).length} manipulable bones found.`, 'success');
        checkReady();
    }

    /**
     * Parses the animation CSV data.
     */
    function parseAnimationCsv(file) {
        setStatus('Parsing animation CSV...', 'info');
        
        animationData = {};
        maxLoadedFrame = 0;

        Papa.parse(file, {
            header: true,
            dynamicTyping: true,
            worker: true,
            skipEmptyLines: true,
            step: function(results) {
                const row = results.data;
                const f = row.frame_number;
                const bid = row.bone_id;

                if (typeof f === 'number' && typeof bid === 'number' && !isNaN(f) && !isNaN(bid)) {
                    if (f > maxLoadedFrame) maxLoadedFrame = f;
                    
                    if (!animationData[f]) animationData[f] = {};
                    
                    // Store the local animation transform (T_frame)
                    animationData[f][bid] = {
                        px: row.position_x, py: row.position_y, pz: row.position_z,
                        rx: row.rotation_x, ry: row.rotation_y, rz: row.rotation_z, rw: row.rotation_w
                    };
                }
            },
            complete: function() {
                setStatus(`Animation loaded. Total frames: ${maxLoadedFrame}.`, 'success');
                ui.maxFrame.textContent = maxLoadedFrame;
                ui.frameNumber.max = maxLoadedFrame;
                ui.frameNumber.value = Math.min(parseInt(ui.frameNumber.value) || 1, maxLoadedFrame);
                checkReady();
            },
            error: function(err) {
                setStatus(`CSV Parsing Error: ${err.message}`, 'error');
                checkReady();
            }
        });
    }

    // ==========================================
    // 4. CORE COMPENSATION LOGIC (SIMPLIFIED V3)
    // ==========================================

    function processAndDownload() {
        const frameToCompensate = parseInt(ui.frameNumber.value);
        
        if (!frameToCompensate || frameToCompensate < 1 || frameToCompensate > maxLoadedFrame) {
            setStatus(`Invalid frame number. Must be between 1 and ${maxLoadedFrame}.`, 'error');
            return;
        }

        const frameData = animationData[frameToCompensate];
        if (!frameData) {
            setStatus(`No animation data found for frame ${frameToCompensate}.`, 'error');
            return;
        }
        
        setStatus(`Calculating compensated skeleton using simplified math...`, 'info');

        const compensatedLocalTransforms = {}; // T'_bind
        
        // --- 1. Calculate New Compensated Local Transforms (T'_bind) ---
        for (const boneName in originalLocalTransforms) {
            const boneId = NAME_TO_ID[boneName];
            const T_bind_local = originalLocalTransforms[boneName];
            const animFrame = frameData[boneId];

            if (animFrame) {
                // T_bind: Original Local Transform (Position: P_bind, Rotation: Q_bind)
                const Q_bind = T_bind_local.rot;
                const P_bind = T_bind_local.pos;

                // T_frame: Animation Local Transform (Position: P_frame, Rotation: Q_frame)
                const Q_frame = new THREE.Quaternion(animFrame.rx, animFrame.ry, animFrame.rz, animFrame.rw);
                const P_frame = new THREE.Vector3(animFrame.px, animFrame.py, animFrame.pz);

                // --- V3 SIMPLIFIED COMPENSATION LOGIC (As requested) ---
                
                // 1. Rotation Compensation: Q'_bind = Q_bind * Q_frame^-1
                const Q_frame_inv = Q_frame.clone().invert();
                const Q_new = Q_bind.clone().multiply(Q_frame_inv);

                // 2. Position Compensation: P'_bind = P_bind - P_frame (Direct subtraction)
                // This is mathematically simple but bypasses the rotation/translation order complexity.
                const P_new = P_bind.clone().sub(P_frame);

                compensatedLocalTransforms[boneName] = { pos: P_new, rot: Q_new };
            } else {
                // If no animation data for this bone, use the original bind pose
                compensatedLocalTransforms[boneName] = T_bind_local;
            }
        }

        // --- 2. Reconstruct Hierarchy and New Global Transforms (T'_global) ---
        const newSkeletonLines = [];
        const newGlobalTransformsCache = { 'root': new THREE.Matrix4() };

        for (const line of originalSkeletonLines) {
            const boneMatch = line.match(/"(.*?)"\s*\[(BONE|Group)\]/);
            const globalMatch = line.match(/G\.Pos:\((.*?)\)\s*\|\s*G\.Rot \(quat\):\((.*?)\)/);

            if (boneMatch && globalMatch) {
                const boneName = boneMatch[1];
                const T_new_local = compensatedLocalTransforms[boneName];

                if (T_new_local) {
                    const parentName = hierarchy[boneName];
                    const T_parent_new_global = newGlobalTransformsCache[parentName] || new THREE.Matrix4();
                    
                    // Compose T'_bind
                    const T_new_bind_matrix = new THREE.Matrix4().compose(T_new_local.pos, T_new_local.rot, new THREE.Vector3(1, 1, 1));
                    
                    // Calculate T'_global = T'_parent_global * T'_bind
                    const T_new_global = T_parent_new_global.clone().multiply(T_new_bind_matrix);
                    
                    // Decompose T'_global for TXT export
                    const P_new_global = new THREE.Vector3();
                    const Q_new_global = new THREE.Quaternion();
                    T_new_global.decompose(P_new_global, Q_new_global, new THREE.Vector3());
                    
                    // Store new global matrix for children
                    newGlobalTransformsCache[boneName] = T_new_global;

                    // 3. Rebuild the TXT Line
                    const newGlobalPosStr = `${P_new_global.x.toFixed(6)},${P_new_global.y.toFixed(6)},${P_new_global.z.toFixed(6)}`;
                    const newGlobalRotStr = `${Q_new_global.x.toFixed(6)},${Q_new_global.y.toFixed(6)},${Q_new_global.z.toFixed(6)},${Q_new_global.w.toFixed(6)}`;
                    
                    // Replace the Global Transform portion of the original line
                    const newLine = line.replace(
                        /G\.Pos:\((.*?)\)\s*\|\s*G\.Rot \(quat\):\((.*?)\)/,
                        `G.Pos:(${newGlobalPosStr}) | G.Rot (quat):(${newGlobalRotStr})`
                    );
                    newSkeletonLines.push(newLine);
                } else {
                    newSkeletonLines.push(line);
                }
            } else {
                 // Preserve non-bone lines 
                newSkeletonLines.push(line);
            }
        }

        // --- 4. Trigger Download ---
        const modifiedContent = newSkeletonLines.join('\n');
        downloadFile(modifiedContent, `compensated_skeleton_V3_F${frameToCompensate}.txt`, 'text/plain');
        
        setStatus(`Successfully generated and downloaded compensated skeleton file.`, 'status-success');
    }

    /**
     * Triggers a browser download of the generated file content.
     */
    function downloadFile(content, filename, mimeType) {
        const blob = new Blob([content], { type: mimeType });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    }

    // ==========================================
    // 5. EVENT LISTENERS
    // ==========================================

    ui.skeletonInput.addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (event) => {
            try {
                parseSkeleton(event.target.result);
            } catch (error) {
                setStatus(`Error processing skeleton: ${error.message}`, 'status-error');
                console.error(error);
            }
        };
        reader.readAsText(file);
    });

    ui.csvInput.addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (!file) return;
        parseAnimationCsv(file);
    });

    ui.processBtn.addEventListener('click', processAndDownload);

    // Initial check
    checkReady();
</script>
</body>
</html>

